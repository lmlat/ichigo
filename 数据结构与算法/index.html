<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构与算法 | 程序员成长指南</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/ichigo/logo.ico">
    <meta name="description" content="记录个人的成长过程, 知识点归纳总结, 从入坑到挖坑的开心时光~">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/ichigo/assets/css/0.styles.cf0a4651.css" as="style"><link rel="preload" href="/ichigo/assets/js/app.8ce08534.js" as="script"><link rel="preload" href="/ichigo/assets/js/3.440a4598.js" as="script"><link rel="preload" href="/ichigo/assets/js/1.7543bd4f.js" as="script"><link rel="preload" href="/ichigo/assets/js/11.d88a996d.js" as="script"><link rel="preload" href="/ichigo/assets/js/9.00897824.js" as="script"><link rel="prefetch" href="/ichigo/assets/js/10.06f06474.js"><link rel="prefetch" href="/ichigo/assets/js/12.40112076.js"><link rel="prefetch" href="/ichigo/assets/js/13.ecbcfc5b.js"><link rel="prefetch" href="/ichigo/assets/js/14.2d4ad4d8.js"><link rel="prefetch" href="/ichigo/assets/js/15.7f02c07a.js"><link rel="prefetch" href="/ichigo/assets/js/16.3e83926b.js"><link rel="prefetch" href="/ichigo/assets/js/17.895365fa.js"><link rel="prefetch" href="/ichigo/assets/js/18.5ce7702c.js"><link rel="prefetch" href="/ichigo/assets/js/19.4026da04.js"><link rel="prefetch" href="/ichigo/assets/js/20.82775ba2.js"><link rel="prefetch" href="/ichigo/assets/js/21.336709a8.js"><link rel="prefetch" href="/ichigo/assets/js/22.cd8ce7e7.js"><link rel="prefetch" href="/ichigo/assets/js/23.de97340d.js"><link rel="prefetch" href="/ichigo/assets/js/24.8136404b.js"><link rel="prefetch" href="/ichigo/assets/js/25.580ae8ec.js"><link rel="prefetch" href="/ichigo/assets/js/4.2bb206fd.js"><link rel="prefetch" href="/ichigo/assets/js/5.4377ba8f.js"><link rel="prefetch" href="/ichigo/assets/js/6.374eca97.js"><link rel="prefetch" href="/ichigo/assets/js/7.d49f5611.js"><link rel="prefetch" href="/ichigo/assets/js/8.8f8e74be.js">
    <link rel="stylesheet" href="/ichigo/assets/css/0.styles.cf0a4651.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>程序员成长指南</h3> <p class="description" data-v-59e6cb88>记录个人的成长过程, 知识点归纳总结, 从入坑到挖坑的开心时光~</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>所幸你是例外</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ichigo/" class="home-link router-link-active"><!----> <span class="site-name">程序员成长指南</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ichigo/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><a href="https://juejin.cn/user/726107228492253" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  导航
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/ichigo/数据结构与算法/" class="nav-link"><i class="undefined"></i>
  数据结构与算法
</a></div><div class="nav-item"><a href="https://juejin.cn/user/726107228492253" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-juejin"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/coding-lin" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <h3 class="name" data-v-1fad0c41>
    所幸你是例外
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>13</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/ichigo/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><a href="https://juejin.cn/user/726107228492253" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  导航
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/ichigo/数据结构与算法/" class="nav-link"><i class="undefined"></i>
  数据结构与算法
</a></div><div class="nav-item"><a href="https://juejin.cn/user/726107228492253" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-juejin"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/coding-lin" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数据结构与算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" aria-current="page" class="active sidebar-link">数据结构与算法</a></li><li><a href="/ichigo/数据结构与算法/LC4_栈.html" class="sidebar-link">栈</a></li><li><a href="/ichigo/数据结构与算法/LC7_堆.html" class="sidebar-link">二叉堆</a></li><li><a href="/ichigo/数据结构与算法/LC排序算法.html" class="sidebar-link">排序算法</a></li><li><a href="/ichigo/数据结构与算法/回溯算法.html" class="sidebar-link">回溯算法</a></li><li><a href="/ichigo/数据结构与算法/左神-数据结构学习.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/ichigo/数据结构与算法/深度优先搜索.html" class="sidebar-link">深度优先搜索</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>所幸你是例外</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">数据结构与算法</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>所幸你是例外</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="header-anchor">#</a> 数据结构与算法</h1> <blockquote><p>先模仿、再学习、然后思考、最后练习</p></blockquote> <p><img src="assets/1680155038813.png" alt="1680155038813"></p> <img src="/ichigo/assets/img/1680155038813.3ef29a9b.png"> <img src="./assets/1680155038813.png"> <h1 id="⭐数组"><a href="#⭐数组" class="header-anchor">#</a> ⭐数组</h1> <h2 id="💡一维数组"><a href="#💡一维数组" class="header-anchor">#</a> 💡一维数组</h2> <h3 id="动态数组"><a href="#动态数组" class="header-anchor">#</a> 动态数组</h3> <h2 id="二维数组"><a href="#二维数组" class="header-anchor">#</a> 二维数组</h2> <h3 id="稀疏数组"><a href="#稀疏数组" class="header-anchor">#</a> 稀疏数组</h3> <h1 id="⭐链表"><a href="#⭐链表" class="header-anchor">#</a> ⭐链表</h1> <h2 id="静态链表"><a href="#静态链表" class="header-anchor">#</a> 静态链表</h2> <p>利用数组维护的链表称为静态链表。使用静态链表存储数据时，需要预先申请一整块连续的内存空间，数据存储有上限。</p> <p>在java中，ArrayList集合就是基于数组实现。</p> <p>简单实现了一个静态链表，它具备二大特性：</p> <ul><li>动态扩容机制</li> <li>支持数据通用性</li></ul> <p>代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h2 id="动态链表"><a href="#动态链表" class="header-anchor">#</a> 动态链表</h2> <p>与静态链表不同，使用动态链表存储数据时，不需要预先申请内存空间，而是按需申请内存空间来存储相关数据。</p> <p>因为是按需分配内存，所以每次申请的内存空间也不一定连续。链表中由一个个节点构成，每个节点由数据域和指针域组成，通过指针域来链接不连续的内存地址存放的数据，从而达到顺序性。</p> <h3 id="单链表"><a href="#单链表" class="header-anchor">#</a> 单链表</h3> <p>单链表是一种链式存储数据结构，它用一组地址存储单元存放数据，再通过链接一个个地址单元，从而实现逻辑有序性。如下所示，链表中的数据通常以节点的形式表示。</p> <p><img src="assets%5C1666538820925.png" alt="1666538820925"></p> <h4 id="存储结构"><a href="#存储结构" class="header-anchor">#</a> 存储结构</h4> <p>单链表的节点由**数据域（val）、后继指针域（next）**组成。数据域就是存储数据的存储单元，指针域就是链接每个节点的地址数据。以下是单链表节点的基本结构：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 节点值</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> val<span class="token punctuation">;</span>
    <span class="token comment">// 后继指针域</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">E</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">LinkedNode</span><span class="token punctuation">(</span><span class="token class-name">E</span> val<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="数据访问"><a href="#数据访问" class="header-anchor">#</a> 数据访问</h4> <p>链表实际上只是一种逻辑上有顺序的线性表，它无法像数组一样支持数据随机访问。因此，在链表中查找指定数据的时间复杂度为O(N)。</p> <h4 id="插入操作"><a href="#插入操作" class="header-anchor">#</a> 插入操作</h4> <p><code>头插</code>：在节点4之前（head节点之后）插入node节点的操作流程图所下所示：</p> <p><img src="assets%5C1666539767702.png" alt="1666539767702"></p> <p><code>尾插</code>：在节点5之后插入节点4的操作流程图所下所示：</p> <p><img src="assets%5C1666539784685.png" alt="1666539784685"></p> <p>在节点2与节点5之间插入节点4的操作流程图所下所示：</p> <p><img src="assets%5C1666539758300.png" alt="1666539758300"></p> <h4 id="删除操作"><a href="#删除操作" class="header-anchor">#</a> 删除操作</h4> <p><code>头删</code>：删除节点2前驱节点的操作流程图如下所示：</p> <p><img src="assets%5C1666592482985.png" alt="1666592482985"></p> <p><code>尾删</code>：除节点2后继节点的操作流程图如下所示：</p> <p><img src="assets%5C1666592803211.png" alt="1666592803211"></p> <p>删除节点4后继节点的操作流程图如下所示：</p> <p><img src="assets%5C1666593627278.png" alt="1666592252037"></p> <blockquote><p><strong>个人总结：</strong></p> <p>单链表是一种逻辑上有顺序的线性表，它能在O(1)的时间复杂度完成插入和删除操作，弥补了数组这一缺陷。美知不足是的它不具备像数组一样的随机访问数据的能力，因此需要在O(N)的时间复杂度完成一样数据访问操作。</p></blockquote> <p>简单实现了一个单链表，它具备三大特性：</p> <ul><li>支持双向访问</li> <li>支持数据随机访问</li> <li>支持单循环链表的转换</li></ul> <p>API介绍：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h3 id="符号链表"><a href="#符号链表" class="header-anchor">#</a> 符号链表</h3> <h3 id="跳表"><a href="#跳表" class="header-anchor">#</a> 跳表</h3> <p>学习跳表之前，首先我们肯定会去思想这样几个问题。</p> <blockquote><p>问题1：什么是跳表？</p> <p>问题2：使用跳表能解决什么问题？</p> <p>问题3：跳表的核心原理是什么？</p></blockquote> <p>带着问题我们一起走进跳表的奇妙之旅。</p> <h4 id="什么是跳表"><a href="#什么是跳表" class="header-anchor">#</a> 什么是跳表</h4> <p>跳表又称跳跃表，它是一种随机化的数据结构，实际上就是一种基于二分思想的<code>有序链表</code>。它在原有的有序链表基础上增加了多级索引，解决了传统链表查询效率慢的问题，将传统链表的查找效率从O(N)提高到O(logN)</p> <h4 id="跳表的性质"><a href="#跳表的性质" class="header-anchor">#</a> 跳表的性质</h4> <ol><li>跳表是一个有序链表。</li> <li>跳表的每一索引链表都是有序的。</li> <li>跳表的节点中包含next和down指针，分别用来指向后继节点和下层索引节点。</li> <li>跳表利用多级索引提高查询性能，利用随机函数保证索引的平衡性。</li></ol> <h4 id="存储结构-2"><a href="#存储结构-2" class="header-anchor">#</a> 存储结构</h4> <p>对于传统链表来说，即便是链表已经有序了，需要查找某个节点时时间复杂度不还是O(N)，而跳表结构的形成，就是在有序链表的基础上，增加了多级索引，如下图所示：</p> <p><img src="assets%5C1667546537853.png" alt="1667546537853"></p> <p>下图是Redis的zset数据类型的原型图，它的底层实现就是基于跳表实现的。</p> <p>图片来源：http://zhangtielei.com/posts/blog-redis-skiplist.html</p> <p>Redis的zset源码：https://github.com/redis/redis/blob/e9aba28932c6a0450c14ecd984603d41f31e0f0d/src/t_zset.c</p> <p><img src="https://pic.leetcode-cn.com/6c6495fabd92eaa88ff8177df06e00e94f4b254d55edd66aa6935be0e088f70e-redis_skiplist_example%20(1).png" alt="redis_skiplist_example (1).png"></p> <p>如上图所示，跳表中最底层才是真正存放数据的链表，每个节点的后继都是level[0]，每一层节点之间的关系都是由level数组进行维护的。相当于，除最底层底表外，其他层（索引层）的节点只有后继指针域（next）。</p> <p>这里为了方便，我实现了节点之间的比较器。跳表的数据节点定义如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SkipNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SkipNode</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 节点值</span>
    <span class="token class-name">T</span> val<span class="token punctuation">;</span>
    <span class="token comment">// level集合记录了当前节点的每一层上的节点信息</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SkipNode</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> level<span class="token punctuation">;</span>

    <span class="token class-name">SkipNode</span><span class="token punctuation">(</span><span class="token class-name">T</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>level <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SkipNode</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>level<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span> 
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">SkipNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="数据访问-2"><a href="#数据访问-2" class="header-anchor">#</a> 数据访问</h4> <p>以上图为例，假设现在要查找目标节点10。</p> <p><code>实现步骤</code>：首先从顶层链表的头节点开始，从左往右扫描：</p> <ul><li>如果当前节点<code>小于</code>目标节点，那么当前节点指向同级的下一个节点；</li> <li>如果当前节点<code>大于</code>目标节点或者扫描到链表中的末尾节点了，那么先退回到同级的前一个节点，然后进入下一级继续查找节点；</li> <li>如果当前节点<code>等于</code>目标节点，说明已经找到目标节点。</li></ul> <p>跳表查找节点23的遍历路径，如下图所示：</p> <p><img src="https://pic.leetcode-cn.com/1614433412-TvWJZk-file_1614433404933" alt="search_path_on_skiplist.png"></p> <h4 id="插入操作-2"><a href="#插入操作-2" class="header-anchor">#</a> 插入操作</h4> <p>在跳表中插入节点的宗旨无非就是<code>维护整表的有序性</code>。</p> <p>假设现在要插入一个新节点6。如下图所示，跳表插入节点6需要遍历的路径（蓝色箭头）。当遍历到节点5时，显然当前节点小于新节点，并且当前节点的后继节点要大于新节点，因此新节点6需要插入到节点5和节点7之间，保证整表有序性。</p> <p><img src="assets%5C1667551140435.png" alt="img"></p> <p><img src="https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif" alt="img"></p> <h4 id="删除操作-2"><a href="#删除操作-2" class="header-anchor">#</a> 删除操作</h4> <p>跳表的删除逻辑与单链表的删除逻辑大同小异，只不过跳表还需要额外处理一下索引节点。因此，<code>在跳表中删除节点时，需要考虑被删除的节点是不是索引节点，如果是的话，那么删除节点本身的同时还需要其所在索引层级中的节点</code>。如下图所示，删除节点7的同时还要将所有索引层级中的节点7删除掉。</p> <p><img src="assets%5C1667948797955.png" alt="1667948797955"></p> <h4 id="索引动态更新"><a href="#索引动态更新" class="header-anchor">#</a> 索引动态更新</h4> <p>在跳表中之所有插入、删除、查找的时间复杂度能保证在O(logN)，无非是借助了索引表的力量。那么，当我们在跳表中一直插入节点而不更新索引时，就会出现部分索引节点间的节点数非常多，极端情况下，跳表就退化成了一个链表，如下图所示。</p> <p><img src="assets%5C1667552789527.png" alt="1667552789527"></p> <p>那么问题来了！</p> <blockquote><p>问题5：如果维护跳表的平衡性呢？</p> <p>答：随机函数。</p></blockquote> <p>当我们在跳表中插入新节点时，可以选择同时将新节点插入到部分索引层中。</p> <blockquote><p>问题6：新节点如何选择加入到哪些索引中呢？</p> <p>答：用一个随机函数来决定新节点插入到哪几级索引中。比如，随机函数生成了值K，那么就将新节点插入到第<code>1~K</code>级索引中。</p></blockquote> <p>现在要插入新节点6，随机函数生成K=2。因此，我们要在每1、2级索引中插入新节点，如下图所示：</p> <p><img src="assets%5C1667553118859.png" alt="1667553118859"></p> <p>下面是一个完整的跳表插入节点流程图：</p> <p><img src="https://pic.leetcode-cn.com/1612247342-QjALhY-skiplist_insertions.png" alt="skiplist_insertions.png"></p> <h4 id="随机数生成器"><a href="#随机数生成器" class="header-anchor">#</a> 随机数生成器</h4> <p>知道了索引动态更新原理之后，最重要的问题就来了，随机函数要怎么设计呢？</p> <p>由于我们要均匀的选取n/2个节点作为索引节点，还要保证原始链表中的节点足够多时，并且选取的索引节点也要足够随机，使得选择出来的索引节点都能够均匀分配，避免出现部分索引节点间的节点数非常多，造成极端情况下，跳表退化成了一个链表惨剧。</p> <p>随机分配原理：每次插入节点时，原始链表（第1级）中一定要插入节点；在第2级索引中插入新节点的概率是50%，在每3级索引中插入新节点的概率是25%，在第4级索引中插入的概率是12.5%，在每5级索引中插入新节点的概率是6.25%，依次类推，在每N级索引中插入新节点的概率为 <code>1/(2^(N-1))</code>。</p> <blockquote><p>💡tip：在Redis的zset结构中的SKIPLIST_P设定的值是0.25，MAX_LEVEL是32。</p></blockquote> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">double</span> <span class="token constant">SKIPLIST_P</span> <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token constant">MAX_LEVEL</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> currLevel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">SKIPLIST_P</span> <span class="token operator">&amp;&amp;</span> currLevel <span class="token operator">&lt;</span> <span class="token constant">MAX_LEVEL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currLevel<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> currLevel<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>个人总结：</p> <p>跳表就是一个在有序链表的基础上增加多级索引节点，是一种典型的空间换时间思想。利用这些索引节点实现链表的二分查找功能，使得一个有序链表能够在O(logN)的时间复杂度完成一次数据访问。美知不足的是，当添加数据时，可能会破坏底层链表的有序性。为了维护底层链表的顺序，就必须先找到一个合适的插入位置，再将数据加入；因此，完成一次插入动作的时间复杂度为O(logN)。当删除数据时，就必须先找到保存待删除数据的前驱，同时还要额外删除多级索引中的数据；因此，完成一次删除动作的时间复杂度为O(logN)。</p></blockquote> <p>简单实现了一个跳表，它具备三大特性：</p> <ul><li>支持双向访问</li> <li>支持数据随机访问</li></ul> <p>API介绍：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h3 id="双向链表"><a href="#双向链表" class="header-anchor">#</a> 双向链表</h3> <p>双向链表（Double Linked List）是在单向链表的基础上进行增强。通过添加前驱指针域来链接前驱节点，从而保证双向访问。</p> <p><img src="assets%5C1666533091292.png" alt="1666533091292"></p> <h4 id="存储结构-3"><a href="#存储结构-3" class="header-anchor">#</a> 存储结构</h4> <p>双向链表的节点由数据域（val）、前驱指针域（prior）、后继指针域（next）组成。节点定义如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 节点值</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> val<span class="token punctuation">;</span>
    <span class="token comment">// 前驱指针域</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prior<span class="token punctuation">;</span>
    <span class="token comment">// 后继指针域</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">LinkedNode</span><span class="token punctuation">(</span><span class="token class-name">E</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">LinkedNode</span><span class="token punctuation">(</span><span class="token class-name">E</span> val<span class="token punctuation">,</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prior<span class="token punctuation">,</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>prior <span class="token operator">=</span> prior<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="插入操作-3"><a href="#插入操作-3" class="header-anchor">#</a> 插入操作</h4> <p>下图展示将node节点插入到curr节点的基本流程。你可以理解为是将node节点插入到curr节点（节点2）之后，也可以理解为是将node节点插入到curr.next节点（节点5）之前。前者是通过尾插法链接其新节点，后者则是通过头插法链接其新节点。</p> <p><img src="assets%5C1666533935774.png" alt="1666533107917"></p> <p><code>头插</code>：在节点4之前（head节点之后）插入节点3（node节点）的基本流程：</p> <p><img src="assets%5C1666535278952.png" alt="1666535278952"></p> <p>头插法代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 将节点插入到目标节点的前面
 *
 * @param target 目标节点
 * @param node 待插入节点
 * @return true插入成功, false插入失败
 */</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span><span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> target<span class="token punctuation">,</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> tail <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>prior <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> target<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>prior <span class="token operator">=</span> node<span class="token punctuation">;</span>
            head <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>prior <span class="token operator">=</span> target<span class="token punctuation">.</span>prior<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>prior <span class="token operator">=</span> node<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> target<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>prior<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>尾插</code>：在节点5之后插入节点3（node节点）的基本流程：</p> <p><img src="assets%5C1666535608781.png" alt="1666535608781"></p> <p>尾插法代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 将node节点插入到target节点的尾部
 *
 * @param target 目标节点
 * @param node 待插入节点
 * @return true插入成功, false插入失败
 */</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> target<span class="token punctuation">,</span> <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> tail <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>prior <span class="token operator">=</span> target<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            tail <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> target<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            target<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>prior <span class="token operator">=</span> target<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prior <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="删除操作-3"><a href="#删除操作-3" class="header-anchor">#</a> 删除操作</h4> <p>下图展示curr节点被删除的基本流程。同插入操作相同，你可以理解为是删除节点4的后继节点，也可以理解为是删除节点5的前驱节点。</p> <p><img src="assets%5C1666534718194.png" alt="1666534718194"></p> <p><code>头删</code>：删除节点2的前驱节点。</p> <p><img src="assets%5C1666595521499.png" alt="1666536516158"></p> <p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment">// 只有一个节点的情况,直接让head和tail指针为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 指向下一个节点</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">// 将待弹出的头节点置为空</span>
        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 将与待弹出的头节点相关联的前驱指针置为空</span>
        head<span class="token punctuation">.</span>prior <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> curr<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>尾删</code>：删除节点2的后继节点。</p> <p><img src="assets%5C1666595672147.png" alt="1666536813800"></p> <p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">LinkedNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> curr <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>prior<span class="token punctuation">;</span>
        curr<span class="token punctuation">.</span>prior <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> curr<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="哈希链表"><a href="#哈希链表" class="header-anchor">#</a> 哈希链表</h3> <p>哈希链表是哈希表与双向链表的产物，而在java中，LinkedHashMap类的底层实现就是基于哈希链表实现的。</p> <p><img src="assets%5C1666867378229.png" alt="1666867378229"></p> <h4 id="存储结构-4"><a href="#存储结构-4" class="header-anchor">#</a> 存储结构</h4> <p>如上所示，它在链表的基础上，把数据用双向链表串起来，一方面可以提高数据的插入、删除、访问性能，另一方面可以保证哈希表节点之间的顺序，节点类型声明如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">HashNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> prior<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="插入操作-4"><a href="#插入操作-4" class="header-anchor">#</a> 插入操作</h4> <h4 id="删除操作-4"><a href="#删除操作-4" class="header-anchor">#</a> 删除操作</h4> <h4 id="访问操作"><a href="#访问操作" class="header-anchor">#</a> 访问操作</h4> <h4 id="lru缓存机制"><a href="#lru缓存机制" class="header-anchor">#</a> LRU缓存机制</h4> <p>LRU（Least Recently Used）最近最少使用，它是一种常用的<code>页面置换算法</code>，选择最近最久未使用的页面予以淘汰。</p> <p>利用单链表方式实现LRU算法其时间复杂度为O(n)，但是通过哈希链表来实现，可以将其插入、删除、查找节点的时间复杂度缩短至O(1)。</p> <p>下图演示了LRU算法的核心原理：</p> <p><img src="assets%5C5a684d96a7d14b4486e3447ae802eb43.gif" alt="img"></p> <h5 id="基于哈希链表实现"><a href="#基于哈希链表实现" class="header-anchor">#</a> 基于哈希链表实现</h5> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h5 id="基于linkedhashmap实现"><a href="#基于linkedhashmap实现" class="header-anchor">#</a> 基于LinkedHashMap实现</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// LinkedHashMap底层结构本身就是哈希表+双向链表。有具体实现afterNodeInsertion方法用来删除最近最少使用的节点（头节点），但是</span>
<span class="token comment">// 其中的removeEldestEntry方法恒返回false，从而导致afterNodeInsertion方法并没有起到作用</span>
<span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存容量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 开启访问顺序</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前哈希表中节点数大于缓存容量数时，才将最近最少使用的节点删除掉</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将被访问过的节点移动到链表末尾</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="循环链表"><a href="#循环链表" class="header-anchor">#</a> 循环链表</h3> <p>循环链表是另一种形式的链式存储结构。通常把它双分为单向循环链表和双向循环链表。</p> <h4 id="单向循环链表"><a href="#单向循环链表" class="header-anchor">#</a> 单向循环链表</h4> <p>单向循环链表的特点就是链表中末尾节点的后继指针域（next）指向头结点，整个链表形成一个环，如下图所示。</p> <p><img src="assets%5C1666539131282.png" alt="1666539131282"></p> <h5 id="插入操作-5"><a href="#插入操作-5" class="header-anchor">#</a> 插入操作</h5> <p>在头节点前插入新节点。如下图所示，在节点4之前插入节点1。</p> <p><img src="assets%5C1666597752037.png" alt="1666597380724"></p> <p>在尾节点后插入新节点。如下图所示，在节点3之后插入节点1。</p> <p><img src="assets%5C1666597794633.png" alt="1666597553780"></p> <p>在非头非尾节点之间插入新节点。如下图所示，在节点2与节点5之间插入节点1。</p> <p><img src="assets%5C1666597039848.png" alt="1666597039848"></p> <h5 id="删除操作-5"><a href="#删除操作-5" class="header-anchor">#</a> 删除操作</h5> <p>删除头节点。如下图所示，将节点4删除，使节点2变为头节点。</p> <p><img src="assets%5C1666596625828.png" alt="1666596625828"></p> <p>删除尾节点。如下图所示，将节点3删除，使节点5变为尾节点。</p> <p><img src="assets%5C1666596791720.png" alt="1666596791720"></p> <p>删除非头非尾的节点。如下图所示，将节点5删除，使节点2的下一个节点变为节点3。</p> <p><img src="assets%5C1666596969884.png" alt="1666596969884"></p> <blockquote><p><strong>个人总结：</strong></p> <p>单向循环链表的插入、删除操作与单链表类似，只不过要维护好其&quot;循环&quot;特征。</p></blockquote> <h4 id="双向循环链表"><a href="#双向循环链表" class="header-anchor">#</a> 双向循环链表</h4> <p>双向循环链表的特点就是链表中尾节点的后继指针域（next）指向头结点，链表中的头节点的前驱指针域（prior）指向尾节点。整个链表形成一个环，如下图所示。</p> <p><img src="assets%5C1666538361534.png" alt="1666535998675"></p> <p>双向循环链表插入、删除操作同双向链表类似，只不过要维护好循环链表本身的&quot;循环&quot;特性即可。</p> <h1 id="⭐字符串"><a href="#⭐字符串" class="header-anchor">#</a> ⭐字符串</h1> <h2 id="字符串哈希"><a href="#字符串哈希" class="header-anchor">#</a> 字符串哈希</h2> <p>定义一个把字符串映射成整数的函数f，这个函数f称为是Hash函数。通过Hash函数快速判断两个字符串是否相等。</p> <p>Hash函数的两个特性：</p> <ol><li>Hash函数值不同时，字符串一定不相等。</li> <li>Hash函数值相同时，字符串不一定相等（大概率是相等的）。</li></ol> <blockquote><p>tip：Hash函数值相同，原字符串内容不同，这种现象称<strong>哈希碰撞</strong>。</p></blockquote> <p>java8中的字符串哈希实现方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
private final char value[];
private int hash; // Default to 0
*/</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// hash的默认值为0</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hash<span class="token punctuation">;</span>
    <span class="token comment">// value：字符串内容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="字符串匹配"><a href="#字符串匹配" class="header-anchor">#</a> 字符串匹配</h2> <p>字符串匹配又称模式匹配。给定字符串S和T，在主串S中寻找子串T。字符T称为模式串。</p> <ul><li>单串匹配：给定一个字符串S和一个模式串T，找出T串在S串中的所有位置。</li> <li>多串匹配：给定一个字符串S和多个模式串（T1，T2，...，Tn），找出这些模式串在S串中的所有位置。</li></ul> <blockquote><p>💡tip：</p></blockquote> <h3 id="单模式匹配"><a href="#单模式匹配" class="header-anchor">#</a> 单模式匹配</h3> <h4 id="bf算法"><a href="#bf算法" class="header-anchor">#</a> BF算法</h4> <p>BF (Brute Force) 算法也称暴力算法。它是模式匹配算法中最朴素的一种算法，如果有一个长度为n的主串S和长度为m的模式串。它的核心思想就是将主串S拆分成n-m+1个长度为m的子串与模式串T进行匹配。</p> <p>假设有主串S=&quot;baddef&quot;，模式串T=&quot;abc&quot;，BF算法的匹配流程如下图所示：</p> <p><img src="assets%5C1665147072718.png" alt="1665147072718"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 主串长度</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 模式串长度</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 主串匹配次数</span>
    <span class="token keyword">int</span> numberOfMatches <span class="token operator">=</span> n <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numberOfMatches<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">!=</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 模式串正常遍历完</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="rk算法"><a href="#rk算法" class="header-anchor">#</a> RK算法</h4> <p>RK（Rabin Karp）算法是针对BF算法进行改进，引入哈希算法来进行优化。它的核心思想是通过哈希算法对主串中的n-m+1个子串分别计算哈希值，然后逐个与模式串的哈希值进行比较。</p> <p><img src="assets%5C1665149244806.png" alt="1665149244806"></p> <p>存在的问题：</p> <ol><li>哈希算法虽然让模式串与子串比较时的效率提高了，但是算法整体效率并没有得到提高。</li> <li>哈希冲突</li></ol> <h4 id="kmp算法"><a href="#kmp算法" class="header-anchor">#</a> KMP算法</h4> <p>KMP（Knuth–Morris–Pratt）是一种改进的字符串匹配算法。它的时间复杂度是 O(m+n)。</p> <p><strong>核心思想</strong>：KMP算法核心是实现前缀函数。它通过计算出模式串字符与主串字符匹配失败时，下一次模式串开始匹配的索引位置，并将索引位置保存到一个数组中，使其尽可能减少模式串与主串的匹配次数，从而达到更高效的匹配算法。</p> <h5 id="朴素前缀函数"><a href="#朴素前缀函数" class="header-anchor">#</a> 朴素前缀函数</h5> <p>给定一个长度为n的字符串S，其前缀函数就是一个长度为n的prefix数组。简单说，prefix数组主要用来记录子串S[0，n-1]最长公共真前后缀的长度。</p> <blockquote><p>约定：前缀数组的首元素为-1，即prefix[0]=-1。</p></blockquote> <p><code>构造前缀数组原理分析</code>：</p> <p>有一个模式串P=&quot;AABAAAB&quot;。那么</p> <p>它的真前缀包含：{&quot;A&quot;，&quot;AA&quot;，&quot;AAB&quot;，&quot;AABA&quot;，&quot;AABAA&quot;，&quot;AABAAA&quot;}。</p> <p>它的真后缀包含：{&quot;B&quot;，&quot;AB&quot;，&quot;AAB&quot;，&quot;AAAB&quot;，&quot;BAAAB&quot;，&quot;ABAAAB&quot;}。</p> <ol><li>prefix[0]=-1，规定前缀数组首元素为-1；</li> <li>prefix[1]=0，因为子串&quot;A&quot;没有真前后缀，所以prefix[1]值为0；</li> <li>prefix[2]=1，因为子串&quot;AA&quot;只有一对相等的真前后缀：&quot;A&quot;，它的长度为1，所以prefix[1]的值为1；</li> <li>prefix[3]=0，因为子串&quot;AAB&quot;没有相等的真前后缀，所以prefix[3]值为0；</li> <li>prefix[4]=1，因为子串&quot;AABA&quot;只有一对相等的真前后缀：&quot;A&quot;，它的长度为1，所以prefix[4]的值为1；</li> <li>prefix[5]=2，因为子串&quot;AABAA&quot;只有一对相等的真前后缀：&quot;AA&quot;，它的长度为2，所以prefix[5]的值为2；</li> <li>prefix[6]=2，因为子串&quot;AABAAA&quot;只有一对相等的真前后缀：&quot;AA&quot;，它的长度为2，所以prefix[6]的值为2；</li></ol> <p><img src="assets%5C1664881159589.png" alt="1664881159589"></p> <p>朴素算法代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calcPrefixFunction</span><span class="token punctuation">(</span><span class="token class-name">String</span> moduleString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// i:主串指针</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建前缀数组, 记录与模式串字符不匹配时，下一步开始匹配的索引位置</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prefix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 前缀数组的首元素为-1, 用来作为头标记。字符串前缀不包含本身</span>
    <span class="token comment">// j:模式串指针</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> prefix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// size-1: 字符串后缀不包含本身</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 匹配成功</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
            prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token comment">// prefix[i]=j可改进为如下代码</span>
            <span class="token comment">// prefix[i] = (moduleString.charAt(i) == moduleString.charAt(j)) ? prefix[j] : j;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 匹配失败后, 下一次模式串要开始匹配的索引位置。有效减少字符串重复匹配。</span>
            j <span class="token operator">=</span> prefix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> prefix<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="朴素前缀函数改进"><a href="#朴素前缀函数改进" class="header-anchor">#</a> 朴素前缀函数改进</h5> <p>当子串在重复部分匹配失败时，会发现之前的KMP算法会一位一位往前比较，如下图所示。其实2，3，4，5步骤的判断是多余的。
因此我们可以直接跳过重复部分，让首字符直接跟发现不匹配字符部分的后一位进行比较。
总结即，子串重复部分的直接回溯到之前相同部分的next处。不在进行累加使next[i] = j;</p> <p><img src="https://img-blog.csdnimg.cn/20190624112906421.jpg" alt="img"></p> <p><img src="https://img-blog.csdnimg.cn/72406720ed3844f7b41f6fe735137b47.png" alt="img"></p> <p>参考文章：</p> <ol><li><a href="https://blog.csdn.net/weixin_48524215/article/details/119321091" target="_blank" rel="noopener noreferrer">KMP模式匹配算法改进<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calcPrefixFunction</span><span class="token punctuation">(</span><span class="token class-name">String</span> moduleString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prefix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> prefix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 改进后</span>
            prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> prefix<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            j <span class="token operator">=</span> prefix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> prefix<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="高效前缀函数"><a href="#高效前缀函数" class="header-anchor">#</a> 高效前缀函数</h5> <p><strong>优化一</strong>：相邻的前缀函数值至多增加1</p> <p><strong>优化二</strong>：</p> <p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calcPrefixFunction</span><span class="token punctuation">(</span><span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prefix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> prefix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            j <span class="token operator">=</span> prefix<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> prefix<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="原理分析"><a href="#原理分析" class="header-anchor">#</a> 原理分析</h5> <p>假设有主串S=&quot;ACTGPACTGKACTGPACY&quot;，模式串T=&quot;ACTGPACY&quot;，前缀数组prefix={-1, 0, 0, 0, 0, 0, 1, 2}</p> <p><img src="assets%5C1664967790155.png" alt="1664967790155"></p> <p><code>实现步骤</code>：</p> <p>originIdx：记录主串当前匹配索引位置</p> <p>moduleIdx：记录模式串当前匹配索引位置</p> <ol><li><p>S串与T串从左往右依次进行比较，直到'T'与'Y'比较失配时，根据前缀数组记录的回退索引值，重置模式串下一次起始匹配的索引位置，originIdx值保持不变。从而减少模式串与主串的匹配次数。</p> <p><img src="assets%5C1664968151306.png" alt="1664966915698"></p></li> <li><p>重置后模式串起始匹配索引moduleIdx=2，直到'K'与'P'比较失配时，重置moduleIdx值为prefix[4]=0。</p> <p><img src="assets%5C1664968327655.png" alt="1664966969641"></p></li> <li><p>重置后模式串起始匹配索引moduleIdx=0，主串当前匹配索引originIdx=10，如下图所示。从左往右依次匹配，直至完成匹配。</p> <p><img src="assets%5C1664968579691.png" alt="1664968579691"></p></li></ol> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算模式串的前缀函数</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prefix <span class="token operator">=</span> <span class="token function">calcPrefixFunction</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// i: 主串指针</span>
    <span class="token comment">// j: 模式串指针</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 主串字符与模式串字符匹配成功</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果匹配失败, 下一步模式串开始匹配的索引位置</span>
            j <span class="token operator">=</span> prefix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h4 id="bm算法"><a href="#bm算法" class="header-anchor">#</a> BM算法</h4> <p>BM（Boyer Moore）算法是目前有效且应用较广泛的一种匹配算法。各种文本编辑器的查找功能（Ctrl+F），大多采用BM算法。相比KMP算法它要快3~5倍。</p> <p><strong>核心思想</strong>：BM算法核心是通过字符串后缀来实现字符跳转。通过坏字符和好前缀计算出模式串移动距离，模式串选择较大距离进行移动，使其尽可能减少模式串与主串的匹配次数，从而达到更高效的匹配算法。</p> <h5 id="坏字符"><a href="#坏字符" class="header-anchor">#</a> 坏字符</h5> <p>定义：模式串从右向左匹配，主串中第一个不匹配的字符就是坏字符。</p> <p><img src="assets%5C1664792494600.png" alt="1664792494600"></p> <p><code>坏字符计算模式串移动距离</code>：</p> <ol><li><p>首先S串与T串头部对齐，然后从T串尾部开始比较。如下图所示，curr表示主串匹配字符的索引位置。'F'和'C'并不匹配，即找到坏字符'F'，其对应T串的索引位置为5。</p> <p><img src="assets%5C1664902712753.png" alt="1664895003664"></p></li> <li><p>从模式串中可以发现并不存在坏字符'F'，说明主串curr=5之前并没有可以与模式串匹配的情况。模式串直接移动到坏字符'F'之后，进行下一次匹配，即模式串移动位数=5-(-1)=6。</p> <p><img src="assets%5C1664902794955.png" alt="1664902794955"></p></li> <li><p>如果坏字符'F'存在模式串中，如下图所示。这时就不能直接移动到坏字符'F'之后，而需要将模式串中的'F'和主串中的'F'对齐，即模式串移动位数=5-4=1。</p> <p><img src="assets%5C1664901176657.png" alt="1664899163867"></p></li></ol> <blockquote><p><strong>总结</strong></p> <p>通过以上实例可以推算出坏字符计算模式串的移动距离公式：<strong>模式串移动距离 = 坏字符索引 - 坏字符在模式串中的索引</strong></p> <p>注：如果在模式串中查找出多个坏字符时，<strong>选择靠后的字符</strong>与主串进行对齐。</p></blockquote> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 通过坏字符计算模式串滑动距离
 * 
 * @param moduleString 模式串
 * @param badChar 坏字符
 * @param index 当前匹配的字符索引
 * @return 返回模式串移动距离
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOfBadChar</span><span class="token punctuation">(</span><span class="token class-name">String</span> moduleString<span class="token punctuation">,</span> <span class="token keyword">char</span> badChar<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 查询坏字符是否存在模式串的指定位置</span>
    <span class="token comment">// (1)如果坏字符在模式串中不存在, 则返回-1</span>
    <span class="token comment">// (2)如果模式串中有多个坏字符, 返回靠后的字符索引</span>
    <span class="token keyword">int</span> badCharLastIndex <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span>badChar<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> index <span class="token operator">-</span> badCharLastIndex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="好后缀"><a href="#好后缀" class="header-anchor">#</a> 好后缀</h5> <p>定义：模式串从右向左匹配，与主串中匹配的字符就是好后缀。</p> <p><img src="assets%5C1664792785536.png" alt="1664792785536"></p> <hr> <p><code>好后缀计算模式串移动距离</code>：</p> <ol><li><p>在模式串中查找到好后缀&quot;AC&quot;，它的起始索引goodIdx=4。找到好后缀后，接着在模式串中查找是否存在与之相匹配的前缀，如下图可知，与之相匹配的前缀起始索引prefixIdx=0。由此可计算出模式串的移动距离=goodIdx-prefixIdx=4。</p> <p><img src="assets%5C1664958788876.png" alt="1664958788876"></p></li> <li><p>如下图所示，模式串为&quot;CKEAC&quot;，好后缀为&quot;AC&quot;，此时在模式串中就无法找到与之相匹配的前缀。如果模式串直接移动到好后缀&quot;AC&quot;之后就有问题，但只需要移动到'A'字符后就好了。由此可计算出模式串的移动距离=goodIdx-prefixIdx=4。</p> <p><img src="assets%5C1664959873764.png" alt="1664959659376"></p></li></ol> <blockquote><p><strong>总结</strong></p> <p>通过以上实例可以推算出好后缀计算模式串的移动距离公式：<strong>模式串移动距离 = 好后缀起始索引 - 模式串中与好后缀匹配的前缀起始索引</strong></p></blockquote> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 通过好后缀计算模式串滑动距离
 *
 * @param moduleString 模式串
 * @param index 当前匹配的字符索引
 * @return 返回模式串移动距离
 */</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">indexOfGoodChar</span><span class="token punctuation">(</span><span class="token class-name">String</span> moduleString<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模式串中没有与好后缀相匹配的前缀时, 返回-1</span>
    <span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> moduleLength <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 好后缀字符数 = 模式串长度 - 当前匹配字符索引 - 1</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> goodSuffixCharNum <span class="token operator">=</span> moduleLength <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> index<span class="token punctuation">;</span> goodSuffixCharNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> goodSuffixCharNum<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> startPrefix <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> goodSuffixCharNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> endSuffix <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>moduleLength <span class="token operator">-</span> goodSuffixCharNum<span class="token punctuation">,</span> moduleLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>startPrefix<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>endSuffix<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 选择靠后的好前缀起始索引</span>
            distance <span class="token operator">=</span> moduleLength <span class="token operator">-</span> goodSuffixCharNum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> distance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="bm原理分析"><a href="#bm原理分析" class="header-anchor">#</a> BM原理分析</h5> <p><img src="assets%5C1664963134543.png" alt="1664963134543"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">String</span> originString<span class="token punctuation">,</span> <span class="token class-name">String</span> moduleString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 主串</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>originString <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> originString<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 模式串</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>moduleString <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> moduleString<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果模式串的长度大于主串的长度，一定不匹配</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>originString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> moduleString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> moduleSuffix <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
        <span class="token keyword">int</span> originNextIndex <span class="token operator">=</span> moduleSuffix<span class="token punctuation">;</span> <span class="token comment">// 主串起始匹配索引, 5</span>
        <span class="token keyword">int</span> moduleIndex <span class="token operator">=</span> moduleSuffix<span class="token punctuation">;</span> <span class="token comment">// 模式串起始匹配索引, 5</span>
        <span class="token keyword">int</span> originPreIndex <span class="token operator">=</span> originNextIndex<span class="token punctuation">;</span> <span class="token comment">// 主串与模式串首次匹配的索引位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>originNextIndex <span class="token operator">&lt;</span> originString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> moduleIndex <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> originChar <span class="token operator">=</span> originString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>originNextIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">char</span> moduleChar <span class="token operator">=</span> moduleString<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>moduleIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 主串与模式串当前字符匹配成功, 从右向左继续匹配, 直到完全匹配为止</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>originChar <span class="token operator">==</span> moduleChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                originNextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
                moduleIndex<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 利用坏字符计算模式串移动距离</span>
                <span class="token keyword">int</span> badMoveDistance <span class="token operator">=</span> <span class="token function">indexOfBadChar</span><span class="token punctuation">(</span>moduleString<span class="token punctuation">,</span> originChar<span class="token punctuation">,</span> moduleIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 利用好后缀计算模式串移动距离</span>
                <span class="token keyword">int</span> goodMoveDistance <span class="token operator">=</span> <span class="token function">indexOfGoodChar</span><span class="token punctuation">(</span>moduleString<span class="token punctuation">,</span> moduleIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 最终模式串移动距离</span>
                <span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>badMoveDistance<span class="token punctuation">,</span> goodMoveDistance<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 计算下一次主串与模式串首次匹配的字符索引位置</span>
                originNextIndex <span class="token operator">=</span> originPreIndex <span class="token operator">+</span> distance<span class="token punctuation">;</span> <span class="token comment">// 5+6 =&gt; 9+4</span>
                <span class="token comment">// 模式串继续从尾部开始与主串进行匹配</span>
                moduleIndex <span class="token operator">=</span> moduleSuffix<span class="token punctuation">;</span>
                <span class="token comment">// 更新主串与模式串首次匹配的索引位置</span>
                originPreIndex <span class="token operator">=</span> originNextIndex<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 字符串完全匹配</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>moduleIndex <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 匹配成功时索引值多减了一次</span>
            <span class="token keyword">return</span> originNextIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h4 id="z函数-扩展kmp"><a href="#z函数-扩展kmp" class="header-anchor">#</a> Z函数（扩展KMP）</h4> <p>LCP(i，j)表示最长公共前缀。</p> <p>对于长度为n的字符串S，定义函数Z(i)为LCP(S，S[i，n-1])，即从i开始的后缀与S串的最长公共子串的长度。</p> <blockquote><p>tip：规定Z函数的第一个元素为0，即Z(0)=0。</p></blockquote> <p>举个例，Z(abacaba)={0，0，1，0，3，0，1}</p> <p><code>Z函数流程分析：</code></p> <blockquote><p>tip：扩展KMP本质上还是KMP，主要是其前缀函数记录与自身最长的公共前缀的长度。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div><h5 id="朴素算法"><a href="#朴素算法" class="header-anchor">#</a> 朴素算法</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 朴素算法: O(n*n), 计算模式串p的Z函数
 * 根据Z函数的定义暴力求解
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">zFun</span><span class="token punctuation">(</span><span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// z[0]=0</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 计算模式串[i, n-1]区间范围的后缀串与模式串p的最长公共前缀的长度</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">+</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">+</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>原理分析</code>：</p> <p>模式串p=&quot;abacaba&quot;</p> <ul><li>当i=1时, z[1]=0, 字符'a'与'b'匹配失败</li> <li>当i=2时, z[2]=0, 字符'a'与'a'匹配成功,  z[2]自增1
<ul><li>z[2]=1,'b'与'c'匹配失败, 结束内层循环</li></ul></li> <li>i=3时, z[3]=0, 字符'a'与'c'匹配失败</li> <li>i=4时, z[4]=0, 字符'a'与'a'匹配成功, z[4]自增1
<ul><li>z[4]=1, 字符'b'与'b'匹配成功,  z[4]自增1</li> <li>z[4]=2, 字符'a'与'a'匹配成功,  z[4]自增1</li> <li>z[4]=3,  i+z[4]=7,  size=7,  条件不成立结束内层循环</li></ul></li> <li>当i=5时, z[5]=0, 字符'a'与'b'匹配失败</li> <li>当i=6时, z[6]=0, 'a'与'a'匹配成功,  z[6]自增1
<ul><li>z[6]=1, i+z[4]=7, size=7, 条件不成立结束内层循环</li></ul></li></ul> <p>最终的z函数结果为:[0,0,1,0,3,0,1]</p> <h5 id="算法优化"><a href="#算法优化" class="header-anchor">#</a> 算法优化</h5> <p>考虑到朴素算法的时间复杂度较高，还需要改进，而优化的思想就是利用已知数据求解未知数据。</p> <p>匹配段（Z-box）：计算Z(i)的过程中，称区间<code>[i，i+z[i]-1]</code>是i的一个匹配段，记作[l，r]，即**[l，r]区间表示模式式串的前缀**。其中要求r尽可能大，匹配段随着i不断移动，在i位置时，[l，r]区间必须包含i。</p> <p>求模式串T=&quot;bacbcbacba&quot;的Z函数：</p> <table><thead><tr><th>索引</th> <th>0</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> <th>5</th> <th>6</th> <th>7</th> <th>8</th> <th>9</th></tr></thead> <tbody><tr><td>模式串</td> <td>b</td> <td>a</td> <td>c</td> <td>b</td> <td>c</td> <td>b</td> <td>a</td> <td>c</td> <td>b</td> <td>a</td></tr> <tr><td>Z(i)</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>4</td> <td>0</td> <td>0</td> <td>2</td> <td>0</td></tr></tbody></table> <p>z[1]=0，i=1，Z-box范围为[1，0]</p> <p>z[2]=0，i=2，Z-box范围为[2，1]</p> <p>==z[3]=1，i=3，Z-box范围为[3，3]==</p> <p>z[4]=0，i=4，Z-box范围为[4，3]</p> <p>==z[5]=4，i=5，Z-box范围为[5，8]==</p> <p>z[6]=0，i=6，Z-box范围为[6，5]</p> <p>z[7]=0，i=7，Z-box范围为[7，6]</p> <p>==z[8]=2，i=8，Z-box范围为[8，9]==</p> <p>z[9]=0，i=9，Z-box范围为[9，8]</p> <p><code>Z-box求Z函数原理分析</code>：</p> <p>假设已求出Z[i−1]的值，以及到i−1位置的Z−box，即[l，r]。</p> <p>（1）当i &gt; r时，如下图所示，i不在[l，r]区间内，无法推导出Z[i]，因此需要通过暴力匹配方式求Z[i]。由于r的值增加了，同时也需要更新匹配段。</p> <p><img src="assets%5C1665222920280.png" alt="1665222920280"></p> <p>（2）当i &lt; r时，如下图所示，因为[l，r]区间表示模式式串的前缀。</p> <p><img src="assets%5C1665222938249.png" alt="1665222938249"></p> <p>（2.1）将[l，r]区间移动至头部，匹配出对应位置的子串，如下图所示。根据匹配段定义可知上图红色区间是完全相等的，因此**[i-l+1，r-l+1]区间与[i，r]区间的子串是相等**的（绿色区间相等）。</p> <p><img src="assets%5C1665223947023.png" alt="1665223947023"></p> <p><img src="assets%5C1665224299576.png" alt="1665224299576"></p> <p>在计算Z[i]之前，所有的Z都被计算过，因此可以利用绿色的这段相等部分来优化。</p> <p>（2.1.1）当Z[i-l+1] &lt; r-l+1时，可以直接利用前面的匹配信息，Z[i]=Z[i-l+1]，同时匹配段不变。</p> <p><img src="assets%5C1665224406970.png" alt="1665224406970"></p> <p>（2.1.2）当Z[i-l+1] &gt;= r-l+1时，此时[i,r]区间子串是一定与前缀相同的，只需要在大于r的部分进行暴力匹配即可。</p> <p><img src="assets%5C1665224514523.png" alt="1665224514523"></p> <blockquote><p>tip：匹配段中的r取值为什么要尽可能靠右？
r值越靠右，上图中绿色区间的范围就越大，这样Z[i-l+1] &lt; r-l+1的情况越多，求得Z函数的效率就会越好。</p></blockquote> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">genZ</span><span class="token punctuation">(</span><span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// z[0] = 0;</span>
    <span class="token comment">// [l,r]区间的子串是模式串的前缀串</span>
    
<span class="token punctuation">}</span>
</code></pre></div><h3 id="多模式匹配"><a href="#多模式匹配" class="header-anchor">#</a> 多模式匹配</h3> <h4 id="自动机"><a href="#自动机" class="header-anchor">#</a> 自动机</h4> <p>自动机一般都指确定有限状态自动机。一个确定有限状态自动机（DFA） 由以下五部分构成：</p> <ol><li><strong>字符集（Σ）</strong>：自动机支持的字符。</li> <li><strong>状态集合（Q）</strong>：如果把一个DFA看成一张有向图，那么DFA中的状态就相当于图上的顶点。</li> <li><strong>起始状态（S）</strong>：它是一个特殊的状态，S是Q中的元素。</li> <li><strong>接受状态集合（F）</strong>：它是一组特殊的状态，F是Q是子集。</li> <li><strong>转移函数</strong>：它是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个 DFA 看成一张有向图，那么 DFA 中的转移函数就相当于顶点间的边，而每条边上都有一个字符。</li></ol> <h4 id="字典树"><a href="#字典树" class="header-anchor">#</a> 字典树</h4> <p>字典树又称前缀树，它是多叉树的一种特殊形式。它充分利用字符串的公共前缀来减低查询时间，节约存储空间，用来保存大量的字符串。</p> <p>图处来源：<a href="https://zhuanlan.zhihu.com/p/146369212" target="_blank" rel="noopener noreferrer">地铁十分钟 | AC自动机<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h5 id="节点结构"><a href="#节点结构" class="header-anchor">#</a> 节点结构</h5> <p>数组表示法：使用数组来存储子节点。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CAPACITY</span> <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录子节点</span>
    <span class="token keyword">private</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token constant">CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>哈希表示法：使用哈希表来存储子节点。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">TrieNode</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="插入节点"><a href="#插入节点" class="header-anchor">#</a> 插入节点</h5> <p>要构建一棵字典树，无非就是不断的进行插入操作。依次插入<code>apple、aply、cold、cool、cook</code>字符串，字典树的构建过程，如下图所示：</p> <p><img src="assets%5Cv2-e06a8939de7df5fa4e7967f820bedda6_b.gif" alt="img"></p> <p><strong>原理总结</strong>：</p> <ol><li><p>将一个单词拆分成多个字符依次遍历。</p></li> <li><p>从根节点出发，判断根节点是否存在与当前字符匹配子节点：</p> <p>（1）存在：指针移动到子节点继续检验下一个字符。</p> <p>（2）不存在：创建一个子节点，并记录在children表中，指针移动到子节点继续检验下一个字符。</p></li></ol> <h5 id="查找节点"><a href="#查找节点" class="header-anchor">#</a> 查找节点</h5> <p>查找单词<code>apple</code>的流程图如下所示：</p> <p><img src="assets%5Cv2-18d47890dbb6d30b4f17dc0e0b98129f_b.gif" alt="1664972191312"></p> <p>查找单词<code>apple</code>的流程图如下所示：</p> <p><img src="assets%5Cv2-bf40ae12c69fa93c9a484a4c102fd776_b.gif" alt="img"></p> <p><strong>原理总结</strong>：</p> <ol><li><p>将一个单词拆分成多个字符依次遍历。</p></li> <li><p>从根节点出发，检测根节点是否存在与当前字符匹配的子节点：</p> <p>（1）存在：指针移动到子节点，继续检查下一个字符。</p> <p>（2）不存在：表示前缀树中不包含该字符的节点。</p></li></ol> <h5 id="删除节点"><a href="#删除节点" class="header-anchor">#</a> 删除节点</h5> <p>删除单词<code>cook</code>流程图所下所示：</p> <p><img src="assets%5Cv2-8e7a802851e304eb16965663e689369b_b.gif" alt="img"></p> <p>删除单词<code>cold</code>流程图所下所示：</p> <p><img src="assets%5Cv2-7005840f5f656a6fc28d7d2c7193bad3_b.gif" alt="img"></p> <p>字典树完整代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrefixTrie</span> <span class="token punctuation">{</span>
    <span class="token comment">// 根节点</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TrieNode</span> root<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">boolean</span> isWord <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">TrieNode</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">PrefixTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> word<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 定义临时结果用来从根节点开始遍历</span>
        <span class="token class-name">TrieNode</span> curr <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> c <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果指定路径不存在，插入一个新单词</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                curr<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 遍历下一个节点</span>
            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 标记是一个单词</span>
        curr<span class="token punctuation">.</span>isWord <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 获取节点
     * 
     * @param word 单词或前缀
     * @return 节点不存在返回null, 否则返回指定节点
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">TrieNode</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> word<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">TrieNode</span> curr <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> c <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">TrieNode</span> subNode <span class="token operator">=</span> curr<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>subNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            curr <span class="token operator">=</span> subNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> curr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 查找单词
     * 
     * @param word 单词
     * @return 单词存在返回true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TrieNode</span> node <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>isWord<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 查找前缀
     * 
     * @param prefix 前缀
     * @return 前缀存在返回true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TrieNode</span> node <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="ac自动机"><a href="#ac自动机" class="header-anchor">#</a> AC自动机</h4> <p>AC自动机（Aho-Corasick automaton）是基于字典树结构并结合KMP思想的一种多模式匹配算法。主要核心还是字典树和KMP。</p> <p><strong>作用</strong>：字典树虽然也能用于多模式匹配，但它每次匹配失败时都需要回溯，如果模式串较长，这个操作就会很耗时。AC自动机借鉴了KMP思想，引入了失配指针，避免了模式串匹配失败时的回溯操作，将时间复杂度优化到O(n)，n为匹配文本内容长度。</p> <p><img src="https://bkimg.cdn.bcebos.com/pic/0d338744ebf81a4c6021c823dd2a6059242da6cc" alt="img"></p> <p>例如模式串cat在字典树中匹配失败，但是字典树中存在cart模式串，失配指针就会指向前缀ca。这样一来就避免了重复匹配前缀操作。</p> <p>给定模式串==&quot;she&quot;、&quot;hers&quot;、&quot;his&quot;、&quot;he&quot;==构建一棵字典树，如下图所示：</p> <p><img src="assets%5C1665069973912.png" alt="1665069973912"></p> <h5 id="失配指针"><a href="#失配指针" class="header-anchor">#</a> 失配指针</h5> <p>失配指针的核心构建原理是利用BFS完成的。通过BFS进行层序遍历，为每一个节点寻找其失配节点。</p> <blockquote><p><strong>约定</strong>：</p> <ol><li>根节点的失配指针指向null。</li> <li>每个模式串首字符节点的失配指针指向根节点。</li></ol></blockquote> <p><code>构建原理</code>：</p> <ul><li>根节点的失配指针指向null，以及所有模式串的首字符节点的失配指针指向根节点。</li> <li>对于非根节点（curNode），获取其父节点的失配节点（mismatchedNode）时，有以下几种情况：
<ul><li>如果mismatchedNode为空，将curNode的失配指针指向根节点；</li> <li>如果mismatchedNode不为空，说明能够匹配，将curNode的失配指针指向mismatchedNode。</li> <li>如果条件都不满足，获取mismatchedNode的失配指针指向的节点。重复上述匹配逻辑，直到匹配成功为止。</li></ul></li></ul> <p>构建过程如下所示：</p> <p><img src="assets%5C178a2984eaf14e9aa2893c1681f6b1dc.gif" alt="178a2984eaf14e9aa2893c1681f6b1dc"></p> <h5 id="模式匹配原理"><a href="#模式匹配原理" class="header-anchor">#</a> 模式匹配原理</h5> <p>多模式匹配的核心是遍历主串字符，逐个在AC自动机中进行匹配，匹配上，则记录相应信息；未匹配上，则跳转到其失配指针指向的节点继续匹配，直到全部匹配完成。</p> <p>以文本串&quot;ushers&quot;为例，以下是AC自动机模式匹配流程图：</p> <p><img src="assets%5C8efa48c46e8046e480e9dae3b58bf493.gif" alt="8efa48c46e8046e480e9dae3b58bf493"></p> <p>AC自动机完整代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>​</p> <h4 id="后缀树"><a href="#后缀树" class="header-anchor">#</a> 后缀树</h4> <p>后缀树其实就类似于一棵字典树，只不过字典树保存的是字符串前缀，而后缀树则保存的是字符串后缀。</p> <p>以字符串S=&quot;banana&quot;，它的后缀包含&quot;a&quot;，&quot;na&quot;，&quot;ana&quot;，&quot;nana&quot;，&quot;anana&quot;，&quot;banana&quot;，由这些后缀构成的一棵完整字典树如下图所示：</p> <p><img src="assets%5C1666529449717.png" alt="1665573155200"></p> <p>如果有多节点都只有一个分支，为了节省空间，可以将单分支进行合并后就能得到一颗压缩后的字典树。</p> <p><img src="assets%5C1665573775214.png" alt="1665573775214"></p> <blockquote><p>压缩字典树的性质：</p> <ol><li>除根节点以外，每个节点都至少有两个分支。</li> <li>分支的标记可以是具有多个字符的字符串。</li> <li>如果原始字符串长度为N，那么分支的总数小于2N。</li></ol></blockquote> <p>压缩字典树本质上只是减少了节点数量，而分支上的标记和叶子节点的后缀仍占用不少空间。</p> <blockquote><p>规定：</p> <ol><li>将叶子节点中保存的后缀串替换成它<strong>在原始字符串中的起始索引</strong>。</li> <li>将分支标记的后缀串替换成它<strong>在原始字符串中的起始索引和结束索引</strong>来表示，即[fromIndex，toIndx]。</li> <li>将非根，非叶子节点存储的内容替换成<strong>根节点到该节点的所有路径上的字符串的长度总和</strong>。这个值表示<strong>字母深度</strong>。</li></ol></blockquote> <p>字符串S=&quot;banana&quot;的完整后缀树结构如下图所示：</p> <p><img src="assets%5C1665575772464.png" alt="1665575772464"></p> <p><code>构建原理分析</code>：</p> <h5 id="插入节点-2"><a href="#插入节点-2" class="header-anchor">#</a> 插入节点</h5> <h5 id="查找节点-2"><a href="#查找节点-2" class="header-anchor">#</a> 查找节点</h5> <h5 id="删除节点-2"><a href="#删除节点-2" class="header-anchor">#</a> 删除节点</h5> <h5 id="压缩原理"><a href="#压缩原理" class="header-anchor">#</a> 压缩原理</h5> <h5 id="转换后缀数组"><a href="#转换后缀数组" class="header-anchor">#</a> 转换后缀数组</h5> <p>后缀树和后缀数组（包括LCP数组）之间可以在线性时间互相转换。</p> <p>通过对后缀树进行中序遍历可以得到后缀数组和LCP数组，显然可以在线性时间内完成；后缀数组和LCP数组也唯一定义了后缀树。</p> <h5 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h5> <ul><li>查找子串</li> <li>统计S串中出现的字符串T的个数</li></ul> <h4 id="后缀数组"><a href="#后缀数组" class="header-anchor">#</a> 后缀数组</h4> <p>定义：将一个字符串的所有后缀按字典排序后得到的数组。</p> <p>后缀数组由sa和rk数组组成：</p> <ul><li><code>sa数组</code>：它记录所有字符串后缀排序后的编号。 Suffix(sa[i])恒小于Suffix(sa[i+1])，1 &lt;= i &lt; n。</li> <li><code>rk数组</code>：名次数组记录着字符串后缀在所有后缀中从小到大排列的名次。</li></ul> <blockquote><p>性质：<strong>sa[rk[i]] = rk[sa[i]] = i</strong></p> <ul><li><strong>rk[i]表示第i个字符串后缀的名次</strong></li> <li><strong>sa[i]表示名次为i的字符串后缀的索引位置</strong></li></ul></blockquote> <p>假如有字符串S=&quot;aabaaaab&quot;，它的后缀包含&quot;aabaaaab&quot;，&quot;abaaaab&quot;，&quot;baaaab&quot;，&quot;aaaab&quot;，&quot;aaab&quot;，&quot;aab&quot;，&quot;ab&quot;，&quot;b&quot;。它的sa数组与rk数组的关系如下图所示：</p> <p><img src="assets%5C1665328214370.png" alt="1665328214370"></p> <h5 id="计算后缀数组"><a href="#计算后缀数组" class="header-anchor">#</a> 计算后缀数组</h5> <p>倍增算法是最常用的一种计算后缀数组的算法，时间复杂度为O(nlog(n))。它的核心思想是==对每个从首字符开始截取且长度为 2^k 的子串进行排序==，相当于把字符串的每个字符进行排序。k从0开始，每次加1，当 2^k 大于n以后，每个字符开始的长度为 2^k 的子串就相当于每个后缀。并且因为没有两个相同的字符串，所以rank中没有相同的值。</p> <p><code>子串截取原理</code>：</p> <p>设置有长度为8的字符串S=&quot;aabaaaab&quot;。</p> <ol><li>当k=0时，截取的字符串长度为 2^k=1，得到的子串结果如下图所示：</li></ol> <p><img src="assets%5C1665589382891.png" alt="1665589382891"></p> <ol start="2"><li><p>当k=1时，截取的字符串长度为 2^k=2，得到的子串结果如下图所示：</p> <p><img src="assets%5C1665660511448.png" alt="1665660511448"></p></li> <li><p>当k=2时，截取的字符串长度为 2^k=4，得到的子串结果如下图所示。==#符号是填充字符==</p></li></ol> <p><img src="assets%5C1665587814449.png" alt="1665587814449"></p> <ol start="4"><li>当k=3时，截取的字符串长度为 2^k=8，得到的子串结果如下图所示。</li></ol> <p><img src="assets%5C1665589205549.png" alt="1665589205549"></p> <ol start="5"><li>当 2^k 大于n时，每个从首字符开始截取且长度为 2^k 的子串就是一个后缀。因为没有两个相同的字符串，所以rank中没有相同的值。</li></ol> <p><code>倍增算法实现</code>：</p> <ol><li>首次排序以长度为1的后缀字符串为排序规则进行排序，得到SA数组，并通过SA数组求出RK数组。</li> <li>接着<strong>截取长度为k的后缀字符串，并以RK数组为排序规则对SA数组进行排序</strong>。排序完成后，根据SA数组求出长度为 2^k 的RK数组。长度为2^k 的后缀字符串的RK总能由长度为k的后缀字符串的RK求出。</li> <li>重复步骤2，直到构造出完整的SA数组。</li></ol> <p>以下是算法具体的原理实现图。</p> <p><img src="assets%5C1665589906426.png" alt="1665589829049"></p> <p><img src="assets%5C1665328249640.png" alt="1665328249640"></p> <p><code>原理分析</code>：</p> <p>第1次排序时，规定以长度为1的后缀字符串为排序规则进行排序，那么能够得到sa=[0，1，3，4，5，6，2，7]。根据后缀数组的性质（sa[rk[i]] = rk[sa[i]] = i）可以推算出rk=[]</p> <div class="language- extra-class"><pre class="language-text"><code>第1次排序前：sa=[0，1，3，4，5，6，2，7]，rk=[97, 97, 98, 97, 97, 97, 97, 98]
第1次排序后：sa=[0, 3, 4, 5, 1, 6, 7, 2]，rk=[97, 97, 98, 97, 97, 97, 97, 98]
tmpRk[1] != tmpRk[0] || 1+1 &lt; 8 &amp;&amp; 0+1 &gt;= 8 || tmpRk[2] != tmpRk[1]  rk[1, ]
</code></pre></div><p>第2次排序时，根据x，y合并结果为排序规则对sa数组进行排序。[11，11，11，11，12，12，20，21]。sa=[0，3，4，5，1，6，7，2]。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h5 id="计算名次数组"><a href="#计算名次数组" class="header-anchor">#</a> 计算名次数组</h5> <div class="language-java extra-class"><pre class="language-java"><code>tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 
sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> j <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> j <span class="token operator">&gt;=</span> size
tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">!=</span> tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> j<span class="token punctuation">]</span>
</code></pre></div><p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* 根据sa数组计算rk数组
* 
* @param j 排序轮次。j=1表示第1轮排序, j=2表示第2轮排序, j=4表示第3轮排序, j=8表示第4轮排序；
*/</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">genRk</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sa<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpRk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>sa<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> tmpRk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	rk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> j <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> j <span class="token operator">&gt;=</span> size <span class="token operator">||</span> tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">!=</span> tmpRk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token operator">++</span>number<span class="token punctuation">)</span> <span class="token operator">:</span> number<span class="token punctuation">;</span>
        <span class="token comment">// 如果编号值大于或者等于字符串总长，说明编号已经分配完了</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="应用与实践"><a href="#应用与实践" class="header-anchor">#</a> 应用与实践</h5> <ul><li>最长公共前缀（LCP）</li></ul> <h4 id="后缀自动机"><a href="#后缀自动机" class="header-anchor">#</a> 后缀自动机</h4> <h1 id="⭐栈"><a href="#⭐栈" class="header-anchor">#</a> ⭐栈</h1> <p>栈（stack）又名堆栈，它是一种运算受限的线性表，它遵循先进入出（LIFO）原则，仅在表尾（栈顶）进行插入、删除操作。</p> <p>向一个栈插入新元素又称进栈、入栈、压栈，它把新元素放到栈顶元素之上，使之成为新的栈顶元素。</p> <p>从一个栈删除元素又称出栈、退栈，它把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p> <p><img src="assets%5C1666000605124.png" alt="1666000605124"></p> <h2 id="数组模拟栈"><a href="#数组模拟栈" class="header-anchor">#</a> 数组模拟栈</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 元素实际个数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 栈顶指针</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 栈尾指针</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 数组实现</span>
    <span class="token keyword">private</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token comment">// 默认容量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ArrayStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        elements<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">E</span> val <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        size<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> elements<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> elements<span class="token punctuation">[</span>tail<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token class-name">E</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>val<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> size <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;ArrayStack[]&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">&quot;ArrayStack[&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="链表模拟栈"><a href="#链表模拟栈" class="header-anchor">#</a> 链表模拟栈</h2> <p>基于数组方式实现的栈数据结构，可能存在数据存不下、一次性申请容量过大导致资源浪费等问题，无法精准的确定栈的大小，合理利用内存空间。以下是一个基于双向链表实现的栈数据结构。</p> <p>代码实现：ELinkedList类是一个基于双向链表实现的容器</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ELinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ELinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> index<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="单调栈"><a href="#单调栈" class="header-anchor">#</a> 单调栈</h2> <p>单调栈通常分为单调递减栈和单调递增栈。</p> <ol><li><strong>单调递增栈</strong>：栈中的元素按照从小到大顺序进行排序。栈顶元素始终最小，栈尾元素始终最大。</li> <li><strong>单调递减栈</strong>：栈中的元素按照从大到小顺序进行排序。栈顶元素始终最大，栈尾元素始终最小。</li></ol> <p><code>入栈过程分析</code>：</p> <ul><li>单调递增栈：若当前入栈元素为e。从栈顶开始遍历，==弹出小于等于e==的元素，直接遇到一个大于e的元素或者栈为空为止，最后元素e入栈。</li> <li>单调递减栈：若当前入栈元素为e。从栈顶开始遍历，==弹出大于等于e==的元素，直接遇到一个大于e的元素或者栈为空为止，最后元素e入栈。</li></ul> <p>以序列nums=[9，2，7，1，6，4，3，5]为例。</p> <p>构建单调递增栈过程：</p> <p>9入栈：(9)</p> <p>2入栈：(9，2)</p> <p>2出栈，7入栈：(9，7)</p> <p>1入栈：(9，7，1)</p> <p>1出栈，6入栈：(9，7，6)</p> <p>4入栈：(9，7，6，4)</p> <p>3入栈：(9，7，6，4，3)</p> <p>3出栈，4出栈，5入栈：(9，7，6，5)</p> <p>构建单调递减栈过程：</p> <p>9入栈：(9)</p> <p>9出栈，2入栈：(2)</p> <p>7入栈：(2，7)</p> <p>7出栈，2出栈，1入栈：(1)</p> <p>6入栈：(1，6)</p> <p>6出栈，4入栈：(1，4)</p> <p>4出栈，3入栈：(1，3)</p> <p>5入栈：(1，3，5)</p> <p><img src="assets%5C1665999539330.png" alt="1665999139180"></p> <h2 id="最值栈"><a href="#最值栈" class="header-anchor">#</a> 最值栈</h2> <p>在一个栈中需要得到栈中的最大或最小值其实很容易。朴素实现就是通过遍历栈中的每一个元素，两两进行比较，从而得到最大或最小元素值。朴素算法实现虽然简单，但是它的时间复杂度为O(n)，那么有没有更高效的实现方式呢？</p> <p>通过维护一个栈，栈中的元素按照一定的顺序进行排列，从而实现一个单调递增或单调递减的栈。</p> <p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxMinStack</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先进后出</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> normalStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从小到大记录元素, 栈顶始终是栈中最小的元素值, 其实是一个单调递增栈</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> minStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从大到小记录元素, 栈顶始终是栈中最大的元素值, 其实是一个单调递减栈</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> maxStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> minStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            minStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> maxStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            maxStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        normalStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> val <span class="token operator">=</span> normalStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当出栈元素与最小栈顶元素相等时, 同时出栈</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> val<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>minStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            minStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 当出栈元素与最大栈顶元素相等时, 同时出栈</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> val<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>maxStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            maxStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> val <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> val <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>normalStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> normalStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在O(1)时间复杂度获取栈中最小值</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>minStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> minStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在O(1)时间复杂度获取栈中最大值</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>maxStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> maxStack<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="header-anchor">#</a> 逆波兰表达式</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpCalc</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> reversePolishExpressionList<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 中缀表达式转换逆波兰表达式
     * 
     * &lt;pre&gt;
     *  ((10*(6/((9+3)*-11)))+17)+5  =====&gt;
     *  (2+1*3) =====&gt;
     * &lt;/pre&gt;
     * 
     * @param infixList 中缀表达式
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">toReversePolishExpression</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> infixList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>infixList <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> infixList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> opStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> resultList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 中缀表达式</span>
        <span class="token comment">// ((10*(6/((9+3)*-11)))+17)+5</span>
        <span class="token comment">// (2+1*3)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> infix <span class="token operator">:</span> infixList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>infix<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&quot;[+\\-*/()]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 1:数字</span>
                resultList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>infix<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>infix<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 2:括号表达式</span>
                opStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>infix<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>infix<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 3:括号表达式</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>opStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">&quot;(&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>opStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    resultList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>opStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                opStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出第一个匹配到的左括号</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 4:其他符号, 目前支持+、-、*、/</span>
                <span class="token comment">// 如果符号栈顶元素优先级大于当前符号元素, 栈顶元素出栈并加入到结果集中</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>opStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">priority</span><span class="token punctuation">(</span>infix<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">priority</span><span class="token punctuation">(</span>opStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    resultList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>opStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 将优先级高的符号入栈</span>
                opStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>infix<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果符号栈中还有符号,直接全部加入到末尾</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>opStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            resultList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>opStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> resultList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">RpCalc</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> infixList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>reversePolishExpressionList <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            reversePolishExpressionList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token function">toReversePolishExpression</span><span class="token punctuation">(</span>infixList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>reversePolishExpressionList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            reversePolishExpressionList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">toReversePolishExpression</span><span class="token punctuation">(</span>infixList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getReversePolishExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> reversePolishExpressionList <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> reversePolishExpressionList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 获取符号优先级
     * 
     * @param op 符号
     * @return 值越大优先级越高
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token class-name">String</span> op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> op<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">&quot;-&quot;</span><span class="token operator">:</span>
            <span class="token keyword">case</span> <span class="token string">&quot;+&quot;</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">&quot;*&quot;</span><span class="token operator">:</span>
            <span class="token keyword">case</span> <span class="token string">&quot;/&quot;</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>reversePolishExpressionList <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>reversePolishExpressionList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token string">&quot;Reverse polish expression is empty!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token function">calc</span><span class="token punctuation">(</span>reversePolishExpressionList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> rp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rp <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rp<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 数字栈</span>
        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> token <span class="token operator">:</span> rp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是数字则入栈, 如果不是+-*/四种符号的其中一个, 那么它就是一个数字</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&quot;[+\\-*/]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是符号, 则弹出数字栈中的两个元素进行计算, 计算结果入栈</span>
                <span class="token keyword">int</span> num1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> num2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token class-name">String</span> op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">&quot;+&quot;</span><span class="token operator">:</span>
                <span class="token keyword">return</span> num2 <span class="token operator">+</span> num1<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">&quot;-&quot;</span><span class="token operator">:</span>
                <span class="token keyword">return</span> num2 <span class="token operator">-</span> num1<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">&quot;*&quot;</span><span class="token operator">:</span>
                <span class="token keyword">return</span> num2 <span class="token operator">*</span> num1<span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">&quot;/&quot;</span><span class="token operator">:</span>
                <span class="token keyword">return</span> num2 <span class="token operator">/</span> num1<span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">RpCalc</span> rpCalc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpCalc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> tokens <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;6&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;9&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-11&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;17&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rpCalc<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rpCalc<span class="token punctuation">.</span>reversePolishExpressionList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="应用与实践-2"><a href="#应用与实践-2" class="header-anchor">#</a> 应用与实践</h2> <h1 id="⭐队列"><a href="#⭐队列" class="header-anchor">#</a> ⭐队列</h1> <p>队列是一种运算受限的线性表，它遵循先进先出 （First In First Out） 原则，又称 FIFO 队列。</p> <p>队列仅限在一端进行插入，另一端进行删除的线性表。</p> <p>如下图所示，新加入的元素始终在队列尾部，先删除的元素始终是队头元素。</p> <p><img src="assets/44b3a817f0880f168de9574075b61bd204fdc77748d4e04448603d6956c6428a-%E5%87%BA%E5%85%A5%E9%98%9F.gif" alt="img"></p> <h2 id="数组模拟队列"><a href="#数组模拟队列" class="header-anchor">#</a> 数组模拟队列</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment">// 表示数组最大容量</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> front<span class="token punctuation">;</span><span class="token comment">// 头</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> tail<span class="token punctuation">;</span><span class="token comment">// 尾</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span><span class="token comment">// 用于存放数据，模拟队列</span>

    <span class="token keyword">public</span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 判断队列是否满
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tail <span class="token operator">==</span> capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
    * 创建迭代器
    */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 校验队列是否为空
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> front <span class="token operator">==</span> tail<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;ArrayQueue[], front=-1, tail=-1&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;ArrayQueue[&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;, front=&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;, tail=&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 队列爆满</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        elements<span class="token punctuation">[</span><span class="token operator">++</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * @return 返回队头元素并删除头元素
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;队列为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">E</span> val <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * @return 返回队头元素
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;队列为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> elements<span class="token punctuation">[</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Iter</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> front <span class="token operator">&lt;</span> tail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="链表模拟队列"><a href="#链表模拟队列" class="header-anchor">#</a> 链表模拟队列</h2> <h2 id="循环队列"><a href="#循环队列" class="header-anchor">#</a> 循环队列</h2> <p>使用数组模拟实现队列存在资源浪费，当我们像队列中添加元素，再清空，再添加，就会出现如下异常，无法重用存储空间。</p> <p><img src="assets%5C1662435827747.png" alt="1662435688147"></p> <p>为<code>重复被浪费的存储空间</code>。 可以使用<code>固定大小的数组</code>和<code>两个指针</code>来指示起始位置和结束位置。</p> <h2 id="双端队列"><a href="#双端队列" class="header-anchor">#</a> 双端队列</h2> <p>双端队列（Double-Ended Queue）是一种具备栈和队列特性的数据结构。它可以在队头或队尾进行插入、删除操作。通常利用双向链表实现。</p> <h2 id="单调队列"><a href="#单调队列" class="header-anchor">#</a> 单调队列</h2> <p>单调队列通常分为单调递减队列和单调递增队列。</p> <ol><li><strong>单调递增队列</strong>：队列中的元素按照从小到大顺序进行排序。队头元素始终最小，队尾元素始终最大。</li> <li><strong>单调递减队列</strong>：队列中的元素按照从大到小顺序进行排序。队头元素始终最大，队尾元素始终最小。</li></ol> <blockquote><p>tip：单调队列的能够在O(1)时间复杂度完成插入、删除、获取容器中的最值元素操作。</p> <p>求解最大值问题只需维护单调递减队列</p> <p>求解最小值问题只需维护单调递增队列</p></blockquote> <p><code>入栈过程分析</code>：</p> <ul><li>单调递增队列：若当前入队元素为e。从队头开始遍历，==弹出小于等于e==的元素，直到遇见一个大于e的元素或者队列为空为止，最后元素e入队。</li> <li>单调递减队列：若当前入队元素为e。从队头开始遍历，==弹出大于等于e==的元素，直到遇见一个大于e的元素或者队列为空为止，最后元素e入队。</li></ul> <p>以序列nums=[1，3，-1，-3，5，3，6，7]为例。</p> <p>构建一个单调递增队列求解区间长度为3的最小值过程：</p> <table><thead><tr><th>操作</th> <th>队列元素</th> <th>指定区间最值</th></tr></thead> <tbody><tr><td>1入队</td> <td><code>{1}</code></td> <td>区间不符</td></tr> <tr><td>3比1大，3入队</td> <td><code>{1，3}</code></td> <td>区间不符</td></tr> <tr><td>-1比队列中所有元素小，1、3出队，-1入队</td> <td><code>{-1}</code></td> <td>[1,3]区间的最小值为-1</td></tr> <tr><td>-3比队列中所有元素小，-1出队，-3入队</td> <td><code>{-3}</code></td> <td>[2,4]区间的最小值为-3</td></tr> <tr><td>5比-3大，5入队</td> <td><code>{-3，5}</code></td> <td>[3,5]区间的最小值为-3</td></tr> <tr><td>3比5小，5出队，3入队</td> <td><code>{-3，3}</code></td> <td>[4,6]区间的最小值为-3</td></tr> <tr><td>-3不属于[5,7]区间，因此-3出队；6比3大，6入队</td> <td><code>{3，6}</code></td> <td>[5,7]区间的最小值为3</td></tr> <tr><td>7比6大，7入队</td> <td><code>{3，6，7}</code></td> <td>[6,8]区间的最小值为3</td></tr></tbody></table> <p>构建单调递减队列求解区间长度为3的最大值过程：</p> <table><thead><tr><th>操作</th> <th>队列元素</th> <th>指定区间最值</th></tr></thead> <tbody><tr><td>1 入队</td> <td><code>{1}</code></td> <td>区间不符</td></tr> <tr><td>3比1大，1出队，3入队</td> <td><code>{3}</code></td> <td>区间不符</td></tr> <tr><td>-1比3小，-1入队</td> <td><code>{3，-1}</code></td> <td>[1,3]区间的最大值为3</td></tr> <tr><td>-3比-1小，-3入队</td> <td><code>{3，-1，-3}</code></td> <td>[2,4]区间的最大值为3</td></tr> <tr><td>5比队列中所有元素大，3、-1、-3出队，5入队</td> <td><code>{5}</code></td> <td>[3,5]区间的最大值为5</td></tr> <tr><td>3比5小，3入队</td> <td><code>{5，3}</code></td> <td>[4,6]区间的最大值为5</td></tr> <tr><td>6比队列中所有元素大，5、3出队，6入队</td> <td><code>{6}</code></td> <td>[5,7]区间的最大值为6</td></tr> <tr><td>7比6大，6出队，7入队</td> <td><code>{7}</code></td> <td>[6,8]区间的最大值为7</td></tr></tbody></table> <h2 id="最值队列"><a href="#最值队列" class="header-anchor">#</a> 最值队列</h2> <p>O(1)时间复杂度求队列最大、最小值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxMinQueue</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> normalQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从大到小记录元素, 队头始终是队列中最大的元素值</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> maxQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从小到大记录元素, 队头始终是队列中最大的元素值</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> minQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>minQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> minQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>maxQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> maxQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 按照降序方式将元素存储到maxQueue队列中</span>
        <span class="token comment">// 入队时与maxQueue队列中的队尾元素进行比较, 如果value值大于队尾元素, 则maxQueue队列需要将队尾较小的元素弹出, 加入当前较大的元素值;</span>
        <span class="token comment">// 举个例子:</span>
        <span class="token comment">// (1)如果normalQueue队列中现有元素:[10, 5, 2], maxQueue队列中现有元素:[10, 5, 2]。</span>
        <span class="token comment">// (2)此时入队value值为7, 它大于maxQueue队列中的队尾元素2和5, 此时需要依次将2和5弹出maxQueue队列；最后将7加入maxQueue队尾，此时maxQueue队列中现有元素为:[10, 7]</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>maxQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> maxQueue<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> minQueue<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            minQueue<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        normalQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        maxQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        minQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果normalQueue队列中有元素: [10, 5, 2, 7, 1, 6], 那么maxQueue队列中则有元素: [10, 7, 6]。</span>
    <span class="token comment">// 执行出队操作:</span>
    <span class="token comment">// (1)当10出队时, 与maxQueue队列的队头元素进行比较, 相等则maxQueue队列头出队, maxQueue=[7, 6];</span>
    <span class="token comment">// (2)当5出队时, 与maxQueue队列的队头元素进行比较, 值小于, maxQueue不变;</span>
    <span class="token comment">// (3)当2出队时, 同(2);</span>
    <span class="token comment">// (4)当7出队时, 与maxQueue队列的队头元素进行比较, 相等则maxQueue队列头出队, maxQueue=[6];</span>
    <span class="token comment">// (5)当1出队时, 与maxQueue队列的队头元素进行比较, 值小于, maxQueue不变;</span>
    <span class="token comment">// (6)当6出队时, 与maxQueue队列的队头元素进行比较, 相等则maxQueue队列头出队, maxQueue=[];</span>
    <span class="token comment">// 到此normalQueue队列已经没有元素,也就不存在最大值了。</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> value <span class="token operator">=</span> <span class="token operator">!</span>normalQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> normalQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>maxQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>maxQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                maxQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>minQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>minQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                minQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;MaxMinQueue{&quot;</span> <span class="token operator">+</span>
                <span class="token string">&quot;normalQueue=&quot;</span> <span class="token operator">+</span> normalQueue <span class="token operator">+</span>
                <span class="token string">&quot;, maxQueue=&quot;</span> <span class="token operator">+</span> maxQueue <span class="token operator">+</span>
                <span class="token string">&quot;, minQueue=&quot;</span> <span class="token operator">+</span> minQueue <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="应用与实践-3"><a href="#应用与实践-3" class="header-anchor">#</a> 应用与实践</h2> <p>https://zhuanlan.zhihu.com/p/437438743</p> <h3 id="最值问题"><a href="#最值问题" class="header-anchor">#</a> 最值问题</h3> <h4 id="洛谷1886滑动窗口"><a href="#洛谷1886滑动窗口" class="header-anchor">#</a> 洛谷1886滑动窗口</h4> <p>区间最值问题。</p> <h3 id="dp优化"><a href="#dp优化" class="header-anchor">#</a> DP优化</h3> <h3 id="前缀和"><a href="#前缀和" class="header-anchor">#</a> 前缀和</h3> <h1 id="树状数组"><a href="#树状数组" class="header-anchor">#</a> 树状数组</h1> <p>https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin</p> <h1 id="树"><a href="#树" class="header-anchor">#</a> 树</h1> <p><img src="https://pic2.zhimg.com/80/v2-81a3a721a4043a29e8db05d5ff546a3d_720w.webp" alt="img"></p> <p>度：节点拥有有子树数。</p> <p><img src="assets%5C1668004324045.png" alt="1668004324045"></p> <p>树的深度（高度）：树中节点的最大层次。</p> <p><img src="assets%5C1668004482730.png" alt="1668004482730"></p> <p><img src="assets%5C1668004429428.png" alt="1668004429428"></p> <blockquote><p>树的性质：</p> <ul><li>树中的节点数=所有节点的度数+1</li></ul></blockquote> <h2 id="存储结构-5"><a href="#存储结构-5" class="header-anchor">#</a> 存储结构</h2> <h3 id="双亲表示法"><a href="#双亲表示法" class="header-anchor">#</a> 双亲表示法</h3> <p><img src="https://pic4.zhimg.com/80/v2-26e79c00d5eec608cb1841d436298293_720w.webp" alt="img"></p> <h3 id="孩子表示法"><a href="#孩子表示法" class="header-anchor">#</a> 孩子表示法</h3> <p><img src="https://pic4.zhimg.com/80/v2-1ddf28688e49ee4d31e5d74551ebc363_720w.webp" alt="img"></p> <h3 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="header-anchor">#</a> 双亲孩子表示法</h3> <p><img src="https://pic4.zhimg.com/80/v2-34c7ae343080e0cf4783d42f3541534f_720w.webp" alt="img"></p> <h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="header-anchor">#</a> 孩子兄弟表示法</h3> <p><img src="https://pic2.zhimg.com/80/v2-b6ec498d209b23801c40d034b88bd855_720w.webp" alt="img"></p> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <blockquote><p>性质：</p> <ol><li>深度为K的二叉树最多有**(2^K)-1**个节点（K&gt;=1）。</li> <li>二叉树的第N层上最多有**2^(N-1)**个节点（N&gt;=1）。</li> <li>二叉树的叶子节点数等于度为2的节点数加1，即<strong>n0=n2+1</strong>。n0表示叶子节点数，n2表示度为2的节点数。</li></ol></blockquote> <h3 id="特殊二叉树"><a href="#特殊二叉树" class="header-anchor">#</a> 特殊二叉树</h3> <h4 id="斜树"><a href="#斜树" class="header-anchor">#</a> 斜树</h4> <p>斜树分为左斜树和右斜树：</p> <ul><li><p><code>左斜树</code>：所有节点都只有左子树的二叉树</p></li> <li><p><code>右斜树</code>：所有节点都只有右子树的二叉树</p></li></ul> <h4 id="满二叉树"><a href="#满二叉树" class="header-anchor">#</a> 满二叉树</h4> <p><a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/7773283?fr=aladdin" target="_blank" rel="noopener noreferrer">百度百科-满二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>如果一棵二叉树的节点要么是叶子节点，要么它有两个子结点的树称满二叉树。</p> <p>一棵深度为k且有(2^k)-1个节点的二叉树称为满二叉树。</p> <blockquote><p>性质：</p> <ol><li>层数为K的满二叉树的节点总数为**(2^K)-1**。</li> <li>层数为K的满二叉树的叶子节点数为<strong>2^(K-1)</strong>。</li></ol></blockquote> <p><img src="assets%5C1668006997048.png" alt="1668006997048"></p> <h4 id="完全二叉树"><a href="#完全二叉树" class="header-anchor">#</a> 完全二叉树</h4> <p>对一颗具有K个节点的二叉树按层序编号，如果编号为i(1&lt;=i&lt;=K)的节点与满二叉树中编号为i的节点在二叉树中的位置完全相同，那么这查二叉树称为完全二叉树。</p> <blockquote><p>性质：</p> <ol><li>叶子节点只能出现在最下两层；最下层的叶子节点集中在树的左边，倒数第二层的叶子节点一定出现在右边。</li> <li>节点度为1，则该节点只有左子树，即不存在只有右子树的情况。</li> <li>具有N个节点的完全二叉树的深度为**⌊logN⌋+1**（logN表示以2为底N的对数，⌊X⌋表示不大于X的最大整数）。</li> <li>如果对一棵有N个节点的完全二叉树的节点按层序编号，则对任一节点index(1&lt;=index&lt;=N)满足以下条件：
<ul><li>若<strong>index=1</strong>，节点index是二叉树的根，无双亲；若index&gt;1，则**[i / 2]**是双亲节点。</li> <li>若<strong>2*index&gt;N</strong>，节点index无左孩子，否则<strong>2*index</strong>为左孩子节点。</li> <li>若<strong>2*index+1&gt;N</strong>，节点index无右孩子，否则<strong>2*index+1</strong>为右孩子节点。</li></ul></li></ol></blockquote> <p>注：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。</p> <p><img src="assets%5C1668007016258.png" alt="1668007016258"></p> <p><img src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img"></p> <h4 id="二叉搜索树"><a href="#二叉搜索树" class="header-anchor">#</a> 二叉搜索树</h4> <p>具备以下性质的二叉树称为二叉搜索树。它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p> <blockquote><p>性质：</p> <ol><li>若任意结点的左子树不空，则左子树上所有节点的值均不大于它的根节点的值。</li> <li>若任意结点的右子树不空，则右子树上所有节点的值均不小于它的根节点的值。</li> <li>任意节点的左、右子树也分别为二叉搜索树</li></ol></blockquote> <h4 id="平衡二叉树"><a href="#平衡二叉树" class="header-anchor">#</a> 平衡二叉树</h4> <p>具备以下性质的二叉搜索树称为平衡二叉树。</p> <p><code>平衡因子 = 左子树的深度 - 右子树的深度</code></p> <blockquote><p>性质：</p> <ol><li>每个节点的的左子树和右子树的高度差不超过1。</li></ol></blockquote> <h3 id="存储结构-6"><a href="#存储结构-6" class="header-anchor">#</a> 存储结构</h3> <h4 id="顺序存储"><a href="#顺序存储" class="header-anchor">#</a> 顺序存储</h4> <p>二叉树的顺序存储其实就是<code>按照层次顺序给数据编号（包含空节点），从左往右将数据节点存储到数组中</code>。</p> <p>在最坏情况下，一棵高度为K的二叉树最多有<strong>2^K-1</strong>个节点，而数组为了存储下这些节点，就必须预先申请足够的存储单元。试想，当二叉树的高度过高，而节点数较少时，势必会浪费内存。如下所示，其中-1表示空结点。</p> <p><img src="https://img-blog.csdnimg.cn/20210223145918502.png" alt="img"></p> <h4 id="链式存储"><a href="#链式存储" class="header-anchor">#</a> 链式存储</h4> <h5 id="二叉链表"><a href="#二叉链表" class="header-anchor">#</a> 二叉链表</h5> <p>二叉树的链式存储通常指二叉链表。如下所示，二叉链表的每个数据节点由<code>数据域、左指针域、右指针域</code>组成。美中不足的是，如果要查找某个节点的双亲节点，需要遍历整棵树。</p> <p><img src="https://img-blog.csdnimg.cn/20210223150652536.png" alt="img"></p> <h5 id="三叉链表"><a href="#三叉链表" class="header-anchor">#</a> 三叉链表</h5> <p>有时为了更加方便的找到某个节点的双亲节点，就衍生出了三叉链表。三叉链表在二叉链表的基础上增加了一个指向父节点的指针域。如下所示，这样找到某个节点的双亲节点，只需要从其父指针开始查找即可。</p> <p><img src="assets%5C1668072993459.png" alt="1668072993459"></p> <h3 id="遍历方式"><a href="#遍历方式" class="header-anchor">#</a> 遍历方式</h3> <h4 id="前序遍历"><a href="#前序遍历" class="header-anchor">#</a> 前序遍历</h4> <p><code>遍历顺序</code>：根 =&gt; 左 =&gt; 右</p> <p><img src="assets%5C1668075248697.png" alt="1668074439429"></p> <p>递归实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>栈实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h4 id="中序遍历"><a href="#中序遍历" class="header-anchor">#</a> 中序遍历</h4> <p><code>遍历顺序</code>： 左 =&gt; 根 =&gt; 右</p> <p><img src="assets%5C1668075368755.png" alt="1668075368755"></p> <p>递归实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>栈实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h4 id="后序遍历"><a href="#后序遍历" class="header-anchor">#</a> 后序遍历</h4> <p><code>遍历顺序</code>：左 =&gt; 右 =&gt; 根</p> <p><img src="assets%5C1668075442546.png" alt="1668075442546"></p> <p>递归实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>栈实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h4 id="层序遍历"><a href="#层序遍历" class="header-anchor">#</a> 层序遍历</h4> <p><code>遍历顺序</code>：逐层遍历</p> <p><img src="assets%5C1668075481525.png" alt="1668075481525"></p> <p>递归实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>栈实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h4 id="⭐遍历序列构造树"><a href="#⭐遍历序列构造树" class="header-anchor">#</a> ⭐遍历序列构造树</h4> <p>根据二叉树遍历方式可以唯一确定一棵二叉树，但是需要满足以下条件：</p> <ol><li>已知二叉树的<strong>前序和中序遍历</strong>结果；</li> <li>已知二叉树的<strong>中序和后序遍历</strong>结果；</li> <li>已知二叉树的<strong>层序和中序遍历</strong>结果；</li></ol> <h3 id="线索二叉树"><a href="#线索二叉树" class="header-anchor">#</a> 线索二叉树</h3> <p>学到这之前，我对二叉树似乎有了新的理解，但线索二叉树又是个什么玩意？先看看下面这查二叉树。</p> <p><img src="assets%5C1668158153139.png" alt="1668158153139"></p> <p>可以发现，一棵仅有7个节点的二叉树就存在8个空指针。这些空指针都未被使用，节点数小也不算什么，节点数一多势必造成空间浪费。为了将这些空指针合理的利用起来，使得每个节点都可以指向自己的前驱节点和后继节点，指向前驱和后继的指针称为线索，加上线索的二叉树称为线索二叉树。</p> <blockquote><p>tip：一棵有N个节点的二叉树有N-1条分支，那么就存在<strong>2*N-(N-1)=N+1</strong>个空指针。</p></blockquote> <p>因此，<code>线索化的原理其实就是在二叉树遍历过程中，重新规划空指针的指向</code>。线索化二叉树的出现就是通过不同的遍历方式改变左、右空指针的指向，合理的利用这些空指针，从而解决空间浪费问题。并且约定每一个空指针必须满足：</p> <blockquote><ol><li>如果当前节点存在前驱节点，则左空指针指向其前驱节点，否则不改变空指针指向。</li> <li>如果当前节点存在后继节点，则右空指针指向其后继节点，否则不改变空指针指向。</li></ol></blockquote> <h4 id="存储结构-7"><a href="#存储结构-7" class="header-anchor">#</a> 存储结构</h4> <p>知道了线索化二叉树的作用之后，就要考虑如何去构建一棵线索化二叉树。如果继续使用二叉链表结构来存储数据节点，会造成左、右指针域职责不单一：</p> <ul><li>当左、右指针域不为空时，它们分别指向当前节点的左孩子或右孩子节点；</li> <li>当左、右指针域为空时，它们分别指向当前节点的前驱或后继节点；</li></ul> <p>这样一来，如果改变了左、右空指针域的指向就无法准确判断它们所有承担的职责。因此，还需要在二叉链表的基础上，为每个节点的左、右指针域增加leftType和rightType二个标志位用来标识它们的职责。约定：</p> <ul><li>当leftType=0时，节点指向左孩子；leftType=1时，节点指向前驱节点。</li> <li>当rightType=0时，节点指向右孩子；rightType=1时，节点指向后继节点。</li></ul> <p><img src="assets%5C1668594666913.png" alt="1668594666913"></p> <h4 id="前序线索二叉树"><a href="#前序线索二叉树" class="header-anchor">#</a> 前序线索二叉树</h4> <p>前序线索化：其实就是按照二叉树的前序遍历，在遍历过程中，将当前节点的左、右空指针分别指向其前驱、后继节点。</p> <p>前序遍历结果为：1245367</p> <p><img src="assets%5C1668611632784.png" alt="1668521979078"></p> <h4 id="中序线索二叉树"><a href="#中序线索二叉树" class="header-anchor">#</a> 中序线索二叉树</h4> <p>中序线索化：其实就是按照二叉树的前序遍历，在遍历过程中，将当前节点的左、右空指针分别指向其前驱、后继节点。</p> <p>中序遍历结果为：4251376</p> <p><img src="assets%5C1668521860582.png" alt="1668521860582"></p> <h4 id="后序线索二叉树"><a href="#后序线索二叉树" class="header-anchor">#</a> 后序线索二叉树</h4> <p>后序线索化：其实就是按照二叉树的后序遍历，在遍历过程中，将当前节点的左、右空指针分别指向其前驱、后继节点。</p> <p>中序遍历结果为：4527631</p> <p><img src="assets%5C1668521830718.png" alt="1668521830718"></p> <h4 id="层序线索二叉树"><a href="#层序线索二叉树" class="header-anchor">#</a> 层序线索二叉树</h4> <p>层序线索化：其实就是按照二叉树的层序遍历，在遍历过程中，将当前节点的左、右空指针分别指向其前驱、后继节点。</p> <p>前序遍历结果为：1245367</p> <p><img src="assets%5C1668612121580.png" alt="1668612121580"></p> <h3 id="哈夫曼树"><a href="#哈夫曼树" class="header-anchor">#</a> 哈夫曼树</h3> <p><img src="https://i0.hdslb.com/bfs/article/3afdfa35b65f79c2e5f136df1636133cfd003c7a.png" alt="img"></p> <h4 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="header-anchor">#</a> 什么是哈夫曼树</h4> <p>权：树节点之间的边对应的数值</p> <p>路径长度：从树中一个节点到另一个节点间经过的边数</p> <p>带树路径长度（WPL）：从树根到每一个叶子节点的带权路径长度之和</p> <p>哈夫曼树：在含有N个带权叶子节点的二叉树中，带权路径长度(WPL)最小的二叉树称为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong>。</p> <p><img src="https://img-blog.csdnimg.cn/20210226154517971.png" alt="在这里插入图片描述"></p> <p>计算二叉树的带权路径长度：</p> <p>(a) WPL = 7*2 + 5*2 + 2*2 + 4*2 = 36</p> <p>(b) WPL = 4*2 + 7*3 + 5*3 + 2*1 = 46</p> <p>(c) WPL = 7*1 + 5*2 + 2*3 + 4*3 = 35</p> <h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="header-anchor">#</a> 构造哈夫曼树</h4> <p>实现步骤：</p> <ol><li>先把有权值的叶子结点按照从大到小（从小到大也可以）的顺序排列成一个有序序列。</li> <li>取最后两个最小权值的结点作为一个新节点的两个子结点，注意相对较小的是左孩子。</li> <li>用第2步构造的新结点替掉它的两个子节点，插入有序序列中，保持从大到小排列。</li> <li>重复步骤2到步骤3，直到根节点出现。</li></ol> <p><img src="https://img-blog.csdnimg.cn/20210226155839813.png" alt="在这里插入图片描述"></p> <h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="header-anchor">#</a> 哈夫曼编码</h4> <p>哈夫曼编码又称为霍夫曼编码，它是现代压缩算法的基础。</p> <p>编码原则：从哈夫曼树的根节点开始，进入左子树则编码号加0，进入右子树则编码号加1，就可以得到对应字母的二进制编码。</p> <p><img src="https://img-blog.csdnimg.cn/20210417111501682.png" alt="在这里插入图片描述"></p> <p>字符编码表：</p> <table><thead><tr><th>A</th> <th>B</th> <th>C</th> <th>D</th> <th>E</th></tr></thead> <tbody><tr><td>1110</td> <td>110</td> <td>0</td> <td>10</td> <td>1111</td></tr></tbody></table> <p>此时字符串ABBBCCCCCCCCDDDDDDEE的哈夫曼编码为1110110110110000000001010101010101111。</p> <ul><li>https://blog.csdn.net/qq_19887221/article/details/125322754</li> <li>https://blog.csdn.net/Demon_LMMan/article/details/115789360</li> <li>https://blog.csdn.net/weixin_60569662/article/details/123364009</li> <li>https://blog.csdn.net/m0_61961937/article/details/127144232</li> <li>https://www.bilibili.com/read/cv8534151</li></ul> <h4 id="数据压缩"><a href="#数据压缩" class="header-anchor">#</a> 数据压缩</h4> <ol><li>以byte的形式读取文件的内容</li> <li>统计各个byte出现次数</li> <li>创建hufman树</li> <li>生成huffman编码</li> <li>压缩</li> <li>存储压缩文件</li></ol> <h4 id="数据还原"><a href="#数据还原" class="header-anchor">#</a> 数据还原</h4> <ol><li>获取huffman编码表</li> <li>根据编码表生成解码表</li> <li>解压</li> <li>存储源文件</li></ol> <h3 id="二叉搜索树-2"><a href="#二叉搜索树-2" class="header-anchor">#</a> 二叉搜索树</h3> <h4 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="header-anchor">#</a> 什么是二叉搜索树</h4> <h4 id="查找操作"><a href="#查找操作" class="header-anchor">#</a> 查找操作</h4> <h4 id="插入操作-6"><a href="#插入操作-6" class="header-anchor">#</a> 插入操作</h4> <h4 id="删除操作-6"><a href="#删除操作-6" class="header-anchor">#</a> 删除操作</h4> <h4 id="二叉搜索树失衡"><a href="#二叉搜索树失衡" class="header-anchor">#</a> 二叉搜索树失衡</h4> <h3 id="平衡二叉树-2"><a href="#平衡二叉树-2" class="header-anchor">#</a> 平衡二叉树</h3> <h4 id="什么是平衡二叉树"><a href="#什么是平衡二叉树" class="header-anchor">#</a> 什么是平衡二叉树</h4> <p>平衡⼆叉树⼜称为AVL树，是⼀种特殊的⼆叉排序树。其<code>左、右子树都是平衡⼆叉树</code>，且<code>左右子树高度之差不超过1</code>。</p> <h4 id="查找操作-2"><a href="#查找操作-2" class="header-anchor">#</a> 查找操作</h4> <h4 id="插入操作-7"><a href="#插入操作-7" class="header-anchor">#</a> 插入操作</h4> <h5 id="ll平衡旋转"><a href="#ll平衡旋转" class="header-anchor">#</a> LL平衡旋转</h5> <h5 id="rr平衡旋转"><a href="#rr平衡旋转" class="header-anchor">#</a> RR平衡旋转</h5> <h5 id="lr平衡旋转"><a href="#lr平衡旋转" class="header-anchor">#</a> LR平衡旋转</h5> <h5 id="rl平衡旋转"><a href="#rl平衡旋转" class="header-anchor">#</a> RL平衡旋转</h5> <h4 id="删除操作-7"><a href="#删除操作-7" class="header-anchor">#</a> 删除操作</h4> <h3 id="红黑树"><a href="#红黑树" class="header-anchor">#</a> 红黑树</h3> <p>红黑树是⼀种⼆叉查找树，但在每个节点增加⼀个存储位表示节点的颜⾊，可以是红或⿊（⾮红即⿊）。</p> <p>通过对任何⼀条从根到叶⼦的路径上各个节点着⾊的⽅式的限制，红⿊树保证最⻓路径不超过最短路径的⼆倍，因</p> <p>而近似平衡。</p> <p>红黑树是⼀种弱平衡⼆叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插⼊，删除操作较</p> <p>多的情况下，通常使⽤红⿊树。</p> <blockquote><p>性质：</p> <ol><li>每个节点⾮红即⿊</li> <li>根节点是⿊的;</li> <li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是⿊的;</li> <li>如果⼀个节点是红⾊的，则它的⼦节点必须是⿊⾊的。</li> <li>对于任意节点⽽⾔，其到叶⼦点树NULL指针的每条路径都包含相同数⽬的⿊节点;</li></ol></blockquote> <h2 id="树与森林"><a href="#树与森林" class="header-anchor">#</a> 树与森林</h2> <h3 id="树-2"><a href="#树-2" class="header-anchor">#</a> 树</h3> <h4 id="树转二叉树"><a href="#树转二叉树" class="header-anchor">#</a> 树转二叉树</h4> <p>转换原理：</p> <ol><li>加线：将所有兄弟节点连成一条线。</li> <li>去线：对树中每个节点，只保留它与每一个孩子节点的连线，删除其它孩子节点的连线。</li></ol> <p><img src="https://img-blog.csdnimg.cn/20210226145948307.png" alt="在这里插入图片描述"></p> <h4 id="二叉树转树"><a href="#二叉树转树" class="header-anchor">#</a> 二叉树转树</h4> <p>转换原理：</p> <ol><li>加线：如果根节点的左节点存在，则将根节点的所有右节点与根节点连成一条线。</li> <li>去线：删除原二叉树中所有节点与右节点的连线。</li> <li>层次调整。</li></ol> <h3 id="森林"><a href="#森林" class="header-anchor">#</a> 森林</h3> <h4 id="森林转二叉树"><a href="#森林转二叉树" class="header-anchor">#</a> 森林转二叉树</h4> <p>转换原理：</p> <ol><li>将森林中的每一棵树转换成二叉树。</li> <li>连线：将每棵树的根节点连成一条线。</li></ol> <p><img src="https://img-blog.csdnimg.cn/20210226150421261.png" alt="img"></p> <h4 id="二叉树转森林"><a href="#二叉树转森林" class="header-anchor">#</a> 二叉树转森林</h4> <p>转换原理：</p> <ol><li>只要存在右孩子节点，就不断删除右孩子节点的连线。</li> <li>将分离后的二叉树转换成树。</li></ol> <h2 id="并查集"><a href="#并查集" class="header-anchor">#</a> 并查集</h2> <h2 id="n叉树"><a href="#n叉树" class="header-anchor">#</a> N叉树</h2> <h1 id="哈希表"><a href="#哈希表" class="header-anchor">#</a> 哈希表</h1> <h1 id="⭐堆"><a href="#⭐堆" class="header-anchor">#</a> ⭐堆</h1> <p>堆是一棵树，满足以下条件的二叉树</p> <p><strong>性质</strong>：</p> <ul><li>堆是一棵完全二叉树</li> <li>堆中每一个节点的值都必须<code>大于等于或者小于等于</code>其孩子节点的值。</li></ul> <p>下图是一个堆的基本结构，并且它的每个节点的值都小于等于其孩子节点。</p> <p><img src="assets%5C1666925632215.png" alt="1666925632215"></p> <p>通常我们会利用一个数组来存储堆的数据，根据上图我们可以得到这个数组为<code>[1，3，2，4，5，6，7]</code>。</p> <p>假设有一棵完全二叉树（不满足堆的性质）如下图所示，那么它的数组表示形式为<code>[1，3，6，4，5，2，7]</code>。</p> <p><img src="assets%5C1666926346390.png" alt="1666926037188"></p> <p>假设根节点的下标为0，那么完全二叉树满足如下特性：</p> <ul><li>树中的第 i 个节点的左子节点下标：<code>left = 2i + 1</code></li> <li>树中的第 i 个节点的右子节点下标：<code>right = left + 1</code></li> <li>对于有 n 个节点的完全二叉树（n&gt;=2），它的最后一个非叶子结点的下标：<code>n / 2 - 1</code></li></ul> <p>那么将数组[1，3，6，4，5，2，7]映射成一棵完全二叉树就是下面这个样式了。</p> <p><img src="assets%5C1667040473389.png" alt="1666951803325"></p> <h2 id="二叉堆"><a href="#二叉堆" class="header-anchor">#</a> 二叉堆</h2> <p><strong>二叉堆是一颗完全二叉树，并且堆中每个节点的值总是不大于其父节点的值</strong>，该完全二叉树的深度为 k，除第 k 层外，其它各层 (1～k-1) 的节点数都达到最大个数，第k 层所有的结点都连续集中在最左边。</p> <p>二叉堆可分为大顶堆和小顶堆两种：</p> <ul><li><strong>大顶堆</strong>：堆中每一个节点的值都<code>大于等于</code>其孩子节点的值。大顶堆的堆根节点总是堆中最大值。</li> <li><strong>小顶堆</strong>：堆中每一个节点的值都<code>小于等于</code>其孩子节点的值。小顶堆的堆根节点总是堆中最小值。</li></ul> <p><img src="assets%5C1666872329931.png" alt="image-20210403031959497"></p> <h3 id="构建建堆"><a href="#构建建堆" class="header-anchor">#</a> 构建建堆</h3> <p>通过我们会利用一个数组存储一棵完全二叉树的节点值。如果我们需要构造一个最小堆，则需要利用下沉算法将数组调整为最小堆的结构，使其满足最小堆的性质即可；反之，如果需要构造一个最大堆，则需要利用上浮算法将数组调整为最大堆的结构。</p> <h4 id="下沉算法"><a href="#下沉算法" class="header-anchor">#</a> 下沉算法</h4> <blockquote><p>问题1：下沉算法要做什么?</p> <p>个人理解：其实它就是将一棵完全二叉树中的所有父节点都&quot;下沉&quot;，从根节点开始循环往复与其值最小的孩子节点比较，若大于孩子节点，说明当前树的结构是不满足堆的性质的，顾而将节点下沉（两两交换），以次类推，直到找不到孩子节点了或者小于其值最小的孩子节点为止。这样一来所有父节点都遍历完，这棵完全二叉树就完全满足堆的性质。</p></blockquote> <p>以数组seq=[6，5，4，3，2，1，0]为例，将其映射成一棵完全二叉树如下。如果现在要把这棵完全二叉树调整成一个最小堆，只需要将0，1，2索引位置的三个父节点向下调整后，就能确定这个最小堆了。</p> <p><img src="assets%5C1666928717339.png" alt="1666928717339"></p> <p><code>核心原理</code>：</p> <ol><li>首先求出左右孩子节点的索引值，确定节点位置；</li> <li>然后用孩子节点的最小值与根节点进行比较：
<ol><li>根节点<code>大于</code>最小孩子节点，说明不满足最小堆的定义，因此将根节点与孩子节点交换；交换完成后，以孩子节点为根节点，重复上术操作，直到当前节点没有左右孩子节点或者当前节点的值小于其左右孩子节点的值</li> <li>根节点<code>小于</code>最小孩子节点，满足最小堆定义，直接结束即可</li></ol></li></ol> <p><code>步骤1</code>：当前根节点为6，它的左右孩子节点分别是5和4，找出左右孩子节点中最小的与根节点进行比较。6大于4，说明该树不满足最小堆的定义顾而要向下调整。如下所示：</p> <p><img src="assets%5C1667041260159.png" alt="1667036758879"></p> <p><code>步骤2</code>：接着以交换成功后的位置为根节点，重复步骤一的操作。</p> <p><img src="assets%5C1667041392265.png" alt="1666950823576"></p> <p><code>步骤3</code>：==直到当前节点没有左右孩子节点或者当前节点的值小于其左右孩子节点的值==为止，这样一来一轮节点下沉调整就结束了。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> parentIdx<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isMaxHeap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> parentNode <span class="token operator">=</span> seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> leftIdx <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parentIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightIdx <span class="token operator">=</span> leftIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftIdx <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isMaxHeap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rightIdx <span class="token operator">&lt;</span> capacity <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>rightIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                leftIdx <span class="token operator">=</span> rightIdx<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>parentNode<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rightIdx <span class="token operator">&lt;</span> capacity <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>rightIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                leftIdx <span class="token operator">=</span> rightIdx<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>parentNode<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 调整节点</span>
        seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span> <span class="token operator">=</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        parentIdx <span class="token operator">=</span> leftIdx<span class="token punctuation">;</span>
        leftIdx <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parentIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        rightIdx <span class="token operator">=</span> leftIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span> <span class="token operator">=</span> parentNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="上浮算法"><a href="#上浮算法" class="header-anchor">#</a> 上浮算法</h4> <blockquote><p>问题1：上浮算法要做什么?</p> <p>个人理解：其实它就是将一棵完全二叉树中的所有叶子节点都&quot;上浮&quot;，从最后一个叶子节点开始循环往复与其父节点比较，若大于父节点，说明当前树的结构不满足堆的性质，顾而将节点上沉（两两交换），以次类推，直到找不到父节点了或者小于其父节点为止。这样一来所有叶子节点都遍历完后，这棵完全二叉树就一定满足堆的性质。</p></blockquote> <p>以数组seq=[1，2，3，4，5，6，7]为例，将其映射成一棵完全二叉树如下。如果现在要把这棵完全二叉树调整成一个最小堆，只需要将3，4，5，6索引位置的三个叶子节点向上调整后，就能确定这个最大堆了。</p> <p><img src="assets%5C1666955172531.png" alt="1666955172531"></p> <p><code>核心原理</code>：</p> <p><code>步骤一</code>：当前节点值为7，它的父节点值为3。7大于3，说明该树不满足最大堆的定义顾而要向上调整。如下所示：</p> <p><img src="assets%5C1667041029782.png" alt="1667041029782"></p> <p><code>步骤二</code>：交换成功后，当前节点的索引位置变为2，此时它的父节点值为1，重复步骤一，直到当前节点没有父节点或者当前节点的值小于父节点值。</p> <p><img src="assets%5C1667041067845.png" alt="1667041067845"></p> <p>这样一来第1轮的上浮调整就结束了。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 将指定位置的节点向上调整
 * 
 * @param seq 堆的映射数组
 * @param index 节点索引
 */</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rise</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> leafNode <span class="token operator">=</span> seq<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> parentIdx <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">:</span> index <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>leafNode<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重置index位置的节点值为seq[parentIdx]</span>
        seq<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 更新当前节点的索引</span>
        index <span class="token operator">=</span> parentIdx<span class="token punctuation">;</span>
        <span class="token comment">// 以当前节点的索引计算出它的父节点索引。若parentIdx大于等于0时, 说明还存在父节点</span>
        parentIdx <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">:</span> index <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 设置当前节点的值</span>
    seq<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> leafNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="插入操作-8"><a href="#插入操作-8" class="header-anchor">#</a> 插入操作</h3> <p>在二叉堆中插入任意一个节点，都有可能破坏二叉堆的性质。而插入操作要做的就是为新节点安排一个合适的位置，使其插入新节点后仍然满足堆的性质。</p> <p>以小根堆为例，其数组存储数据为[1，2，3，4，5，6，7]，将其映射成一颗完全二叉树如下所示。</p> <p><img src="assets%5C1666955172531.png" alt="1666955172531"></p> <p><code>步骤一</code>：现在要在小根堆中添加一个新节点，节点值为0。首先将新节点插入到尾部，如下图所示。此时这棵树已经不满足最小堆的性质。</p> <p><img src="assets%5C1667043848100.png" alt="1667043848100"></p> <p><code>步骤二</code>：为了满足小根堆的定义，顾而需要将新节点向上调整。若新节点（0）小于其父节点（4），两两交换。如下所示。</p> <p><img src="assets%5C1667043997555.png" alt="1667043997555"></p> <p><code>步骤三</code>：此时新节点的索引值变成了3。重复步骤二，直到新节点的值大于其父节点或者新节点已经是根节点为止。</p> <p><img src="assets%5C1667044517186.png" alt="1667044517186"></p> <p>curr指向的节点又经过了3轮调整之后，就得到了最终的最小堆。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不能添加null节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resize</span><span class="token punctuation">(</span>capacity <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token comment">// 将刚添加的节点向上调整</span>
    <span class="token function">rise</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="删除操作-8"><a href="#删除操作-8" class="header-anchor">#</a> 删除操作</h3> <p>删除操作一般指删除堆中的根节点（堆顶元素）。那么删除根节点，堆结构必定会遭到破坏，这些就要利用下沉或上浮算法调整堆的结构。</p> <p>以大根堆为例，其数组存储数据为[6，5，4，3，2，1]，现在要删除根节点6，基本流程如下：</p> <p><img src="assets%5C1666928825878.png" alt="1666928825878"></p> <p><code>步骤一</code>：将根节点与最后一个节点交换位置，然后删除掉最后一个节点，即根节点。如下图所示，此时新的根节点并不满足大顶堆的定义，因此需要利用下沉算法调整大顶堆的结构。</p> <p><img src="assets%5C1666928911021.png" alt="1666928911021"></p> <p><code>步骤二</code>：找到当前根节点（0）中值最大的孩子节点（5）进行交换。交换完成后，如下图所示。</p> <p><img src="assets%5C1666928986465.png" alt="1666928986465"></p> <p><code>步骤三</code>：此时，以交换成功后的索引位置为根节点，继续重复步骤二，直到当前根节点找不到孩子节点或者根节点大于它的左右孩子节点。</p> <p><img src="assets%5C1666929052678.png" alt="1666929052678"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elements <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> elements<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">E</span> oldVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span>elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除根节点后, 需要向下调整堆结构</span>
    <span class="token function">sink</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> heapType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="手写二叉堆"><a href="#手写二叉堆" class="header-anchor">#</a> 手写二叉堆</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">day8</span>堆<span class="token punctuation">.</span>heap<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">AbstractQueue</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collection</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 堆
 * 
 * @Author : ai.tao
 * @Create : 2022/10/27 19:49
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryHeap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 堆的类型, 大根堆为true，小根堆为false</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> heapType<span class="token punctuation">;</span>
    <span class="token comment">// 节点元素</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token comment">// 默认堆大小</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Comparator</span> comparator<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> elements<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token class-name">Comparator</span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> initialCapacity<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>heapType <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elements <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">// 利用下沉算法调整堆结构</span>
            <span class="token function">downAdjust</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> heapType<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">BinaryHeap</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> heapType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>heapType <span class="token operator">=</span> heapType<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>heapType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Comparator</span> <span class="token function">getComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> comparator<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不能添加null节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">resize</span><span class="token punctuation">(</span>capacity <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token comment">// 将刚添加的节点向上调整</span>
        <span class="token function">rise</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elements <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> elements<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">E</span> oldVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span>elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 删除根节点后, 需要向下调整堆结构</span>
        <span class="token function">sink</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> heapType<span class="token punctuation">)</span><span class="token punctuation">;</span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        size<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> elements <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> elements<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span>elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Iter</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;数组开始扩容,扩容后容量为:&quot;</span> <span class="token operator">+</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建临时数组</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 开始拷贝</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        elements <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">upwardAdjust</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> size <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> idx<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">rise</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;第%d趟: %s%n&quot;</span><span class="token punctuation">,</span> count<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;构建最小堆:&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">downAdjust</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> heapType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">boolean</span> heapType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// buildHeap(seq, i, seq.length, heapType);</span>
            <span class="token function">sink</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> i<span class="token punctuation">,</span> seq<span class="token punctuation">.</span>length<span class="token punctuation">,</span> heapType<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;第%d趟: %s%n&quot;</span><span class="token punctuation">,</span> count<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;构建最%s堆:%s%n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>heapType <span class="token operator">?</span> <span class="token string">&quot;大&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;小&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 将指定位置的节点向上调整
     * 
     * @param seq 堆的映射数组
     * @param index 节点索引
     */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rise</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> leafNode <span class="token operator">=</span> seq<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> parentIdx <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">:</span> index <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>leafNode<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 重置index位置的节点值为seq[parentIdx]</span>
            seq<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 更新当前节点的索引</span>
            index <span class="token operator">=</span> parentIdx<span class="token punctuation">;</span>
            <span class="token comment">// 以当前节点的索引计算出它的父节点索引。若parentIdx大于等于0时, 说明还存在父节点</span>
            parentIdx <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token operator">:</span> index <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 设置当前节点的值</span>
        seq<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> leafNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> parentIdx<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isMaxHeap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> parentNode <span class="token operator">=</span> seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> leftIdx <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parentIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightIdx <span class="token operator">=</span> leftIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftIdx <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isMaxHeap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rightIdx <span class="token operator">&lt;</span> capacity <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>rightIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    leftIdx <span class="token operator">=</span> rightIdx<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>parentNode<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rightIdx <span class="token operator">&lt;</span> capacity <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>rightIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    leftIdx <span class="token operator">=</span> rightIdx<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>parentNode<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 调整节点</span>
            seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span> <span class="token operator">=</span> seq<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
            parentIdx <span class="token operator">=</span> leftIdx<span class="token punctuation">;</span>
            leftIdx <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parentIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            rightIdx <span class="token operator">=</span> leftIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        seq<span class="token punctuation">[</span>parentIdx<span class="token punctuation">]</span> <span class="token operator">=</span> parentNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="时间-空间复杂度"><a href="#时间-空间复杂度" class="header-anchor">#</a> 时间&amp;空间复杂度</h3> <table><thead><tr><th>操作</th> <th>时间复杂度</th> <th>空间复杂度</th></tr></thead> <tbody><tr><td>构建堆</td> <td>O(N)</td> <td>O(N)</td></tr> <tr><td>插入操作</td> <td>O(logN)</td> <td>O(1)</td></tr> <tr><td>删除操作</td> <td>O(logN)</td> <td>O(1)</td></tr> <tr><td>获取堆顶节点</td> <td>O(1)</td> <td>O(1)</td></tr></tbody></table> <h2 id="左偏堆"><a href="#左偏堆" class="header-anchor">#</a> 左偏堆</h2> <h2 id="配对堆"><a href="#配对堆" class="header-anchor">#</a> 配对堆</h2> <h1 id="图"><a href="#图" class="header-anchor">#</a> 图</h1> <blockquote><p>定义：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示G(V，E)。G表示一个图，V表示G中的一个顶点，E表示G中的一条边。</p></blockquote> <p>图是一种是一种非线性的数据结构，它可以用来表示多对多关系。</p> <p><img src="assets%5C1663725448564.png" alt="1663725448564"></p> <p><code>顶点</code>：图中的一个数据元素</p> <p><code>无向边</code>：图中任意一个顶点v(i)到v(j)之间的边没有方向。</p> <p><code>有向边/弧</code>：图中任意一个顶点v(i)到v(j)之间的边有方向。</p> <p><code>度</code>：无向图顶点的边数。</p> <p><code>入度和出度</code>：有向图的顶点分为入度和出度。以顶点为头的 	；以顶点为尾的弧的数目称为出度；<code>有向图的度=入度+出度</code>。</p> <p><code>稀疏图</code>：存在极少的边或弧的图。</p> <p><code>稠密图</code>：存在较多的边或弧的图。</p> <p><code>顶点序列</code>：图中顶点v(i)到v(j)的路径。</p> <p><code>简单路径</code>：图中顶点v(i)到v(j)的路径中不存在相同顶点。</p> <p><code>回路/环</code>：从图的第一个顶点到最后一个顶点相同的路径。</p> <p><code>连通性</code>：无向图中顶点v(i)到v(j)存在路径。</p> <p><code>连通分量</code>：无向图中极大连通子图。</p> <p><code>强连通性</code>：有向图中顶点v(i)到v(j)，v(j)到v(i)都存在路径。</p> <p><code>强连通分量</code>：有向图中极大强连通子图。</p> <p><code>生成树</code>：无向图中连通且n个顶点存在n-1条边的。</p> <p><code>有向树</code>：图中存在一个顶点入度为0，其它顶点出度都为1的。</p> <h2 id="无向图"><a href="#无向图" class="header-anchor">#</a> 无向图</h2> <h2 id="有向图"><a href="#有向图" class="header-anchor">#</a> 有向图</h2> <h2 id="带权图"><a href="#带权图" class="header-anchor">#</a> 带权图</h2> <blockquote><p>定义：在图中任意2个顶点之间的边或弧上都存在一个数值，这个数称为权（Weight），这个图称为带权图或网。</p></blockquote> <h3 id="带权无向图"><a href="#带权无向图" class="header-anchor">#</a> 带权无向图</h3> <h3 id="带权有向图"><a href="#带权有向图" class="header-anchor">#</a> 带权有向图</h3> <h2 id="完全图"><a href="#完全图" class="header-anchor">#</a> 完全图</h2> <blockquote><p>定义：在图中任意两个顶点都存在边或弧，称为完全图。</p></blockquote> <h3 id="无向完全图"><a href="#无向完全图" class="header-anchor">#</a> 无向完全图</h3> <p><code>无向完全图的边数 = n * (n - 1) / 2</code>, n表示图中的顶点数。</p> <h3 id="有向完全图"><a href="#有向完全图" class="header-anchor">#</a> 有向完全图</h3> <p><code>有向完全图的边数 = n * (n - 1)</code>, n表示图中的顶点数。</p> <h2 id="连通图"><a href="#连通图" class="header-anchor">#</a> 连通图</h2> <blockquote><p>定义：图中任意两个顶点都是连通的，称为边能图。</p></blockquote> <h2 id="存储方式"><a href="#存储方式" class="header-anchor">#</a> 存储方式</h2> <h3 id="邻接矩阵"><a href="#邻接矩阵" class="header-anchor">#</a> 邻接矩阵</h3> <p>邻接顶点：</p> <p><img src="assets%5C1663736813096.png" alt="1663736729324"></p> <p>判断D的第一个邻接顶点：定位顶点D行，从左往右查找，第一个与之关联的顶点就是要找的邻接顶点。D的第一个邻接顶点是顶点A，A的第一个邻接顶点是顶点B，B的每一个邻接顶点是顶点A</p> <p><img src="assets%5C1663738634073.png" alt="1663738634073"></p> <p>判断D的下一个邻接顶点：定位顶点D行，从左往右查找，与之有关联的所有顶点都算它的下一个邻接顶点。</p> <p><img src="assets%5C1663738673316.png" alt="1663738673316"></p> <h3 id="邻接表"><a href="#邻接表" class="header-anchor">#</a> 邻接表</h3> <h3 id="十字链表"><a href="#十字链表" class="header-anchor">#</a> 十字链表</h3> <p>为了解决使用邻接表方式处理有向图无法同时求出任意顶点的出度和入度问题，提出了十字链表结构。</p> <p>解决的问题：它是专门用来解决有向图的出度和入度问题。</p> <p>核心思想：结合邻接表和逆邻接表作用，为每个顶点分配两个指针域，一个指向当前顶点为弧头，另一个指向当前顶点的弧尾。</p> <p>==注：箭头方法是弧头；非箭头方法是弧尾==</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">VNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> val<span class="token punctuation">;</span> <span class="token comment">// 顶点信息</span>
    <span class="token class-name">ENode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> firstIn<span class="token punctuation">;</span> <span class="token comment">// 入边表头指针域（顶点是弧尾），指向的链表是一个逆邻接表，计算入度</span>
    <span class="token class-name">ENode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> firstOut<span class="token punctuation">;</span> <span class="token comment">// 出边表头指针域（顶点是弧头），指向的链表是一个邻接表，计算出度</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ENode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> headVex<span class="token punctuation">;</span> <span class="token comment">// 弧头在顶点数组中的下标</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> tailVex<span class="token punctuation">;</span> <span class="token comment">// 弧尾在顶点数组中的下标</span>
    <span class="token keyword">private</span> <span class="token class-name">ENode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> headLink<span class="token punctuation">;</span> <span class="token comment">// 指向下一个以当前顶点为弧头的弧；</span>
    <span class="token keyword">private</span> <span class="token class-name">ENode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> tailLink<span class="token punctuation">;</span> <span class="token comment">// 指向下一个以当前顶点为弧尾的弧；</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="assets%5C1663757924629.png" alt="1663757924629"></p> <p>v(0)有v(1)和v(2)的入边，因此v(0)的firstIn指向v(1)中边表结点headVex=0的结点，接着由入边结点headLink指向下一个入边顶点v(2)中边表结点headVex=0的结点。</p> <p>而v(1)有v(2)的入边，因此v(1)的firstIn指向v(2)中边表结点headVex=1的结点。</p> <h3 id="多重邻接表"><a href="#多重邻接表" class="header-anchor">#</a> 多重邻接表</h3> <p>对于无向图的邻接表，在进行边操作时，比如删除(v0，v2)这条边，需要先找到这条边的两个顶点，再进行删除操作。</p> <p><img src="assets%5C1663764433097.png" alt="1663764433097"></p> <p>邻接多重表是在邻接表的基础上改进的，因为十字链表是适合有向图的，所以需要一个数据结构适合无向图，也就是邻接多重表。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> 
</code></pre></div><h3 id="边集数组"><a href="#边集数组" class="header-anchor">#</a> 边集数组</h3> <p>边集数组是由顶点数组和边数组组成的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EdgeArrayGraph</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录顶点相关信息</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> vertices<span class="token punctuation">;</span>
    <span class="token comment">// 记录边相关信息</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> begin<span class="token punctuation">;</span>
    <span class="token keyword">int</span> end<span class="token punctuation">;</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如下图所示，边集数组更多的是关注边的相关操作，如果在边集数组中尝试查找一个顶点的度，需要扫描整个边数组，效率较低。</p> <p><img src="assets%5C1663839870788.png" alt="1663839870788"></p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><table><thead><tr><th style="text-align:left;"></th> <th>优点</th> <th style="text-align:left;">缺点</th></tr></thead> <tbody><tr><td style="text-align:left;">邻接矩阵</td> <td>实现简单，能同时求任意顶点的出度和入度</td> <td style="text-align:left;">在存储稀疏图时会造成空间浪费</td></tr> <tr><td style="text-align:left;">邻接表</td> <td>使用数组链表实现，不会造成空间浪费</td> <td style="text-align:left;">不能同时求出任意顶点的出度和入度， 除非同时构建邻接表和逆邻接表，对边 进行操作时需要操作两次</td></tr> <tr><td style="text-align:left;">十字链表</td> <td>使用数组链表实现，不会造成空间浪费 同时可以求出某个顶点的入度和出度</td> <td style="text-align:left;">对边进行操作时需要操作两次</td></tr> <tr><td style="text-align:left;">邻接多重表</td> <td>对边的操作进行了优化，操作边的次数由两次减少到了一次</td> <td style="text-align:left;">删除操作较为复杂</td></tr> <tr><td style="text-align:left;">边集数组</td> <td>实现简单，能够高效的处理边的相关操作</td> <td style="text-align:left;">获取指定顶点的度需要遍历整个边数组，效率较低</td></tr></tbody></table> <h3 id="链式前向星"><a href="#链式前向星" class="header-anchor">#</a> 链式前向星</h3> <p>前向星是一种特殊的边集数组。</p> <p>边集数组特性：</p> <ol><li>起点不同时，边集数组中的每一条边<strong>按照<code>起点</code>从小到大排序</strong>；</li> <li>起点相同时，边集数组中的每一条边<strong>按照<code>终点</code>从小到大排序</strong>；</li></ol> <h2 id="遍历方式-2"><a href="#遍历方式-2" class="header-anchor">#</a> 遍历方式</h2> <h3 id="深度优先搜索"><a href="#深度优先搜索" class="header-anchor">#</a> 深度优先搜索</h3> <p>递归模板：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token class-name">Node</span> cur<span class="token punctuation">,</span> <span class="token class-name">Node</span> target<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> visited<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token keyword">if</span> cur is target<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>next <span class="token operator">:</span> each neighbor of cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next is not in visited<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            add next <span class="token keyword">to</span> <span class="token namespace">visted</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token keyword">if</span> <span class="token function">DFS</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> target<span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>显示栈模板：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> visited<span class="token punctuation">;</span>
    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">;</span>
    add root <span class="token keyword">to</span> <span class="token namespace">s</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>s is not empty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> cur <span class="token operator">=</span> the top element in s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token keyword">if</span> cur is target<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> next <span class="token operator">:</span> the neighbors of cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>next is not in visited<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                add next <span class="token keyword">to</span> <span class="token namespace">s</span><span class="token punctuation">;</span>
                add next <span class="token keyword">to</span> <span class="token namespace">visited</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        remove cur from s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="广度优先搜索"><a href="#广度优先搜索" class="header-anchor">#</a> 广度优先搜索</h3> <p>模板：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h1 id="递归-分治"><a href="#递归-分治" class="header-anchor">#</a> 递归 &amp; 分治</h1> <h2 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h2> <p>递归在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种<strong>通过重复将问题分解为同类的子问题而解决问题</strong>的方法。</p> <p>在编程语言的中，递归（Recursion）是指函数自己调用自己的语法现象。</p> <p>递归的基本思想是<strong>某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题</strong>。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</p> <blockquote><p>递归最重要的两个特性：</p> <ul><li>终止条件：单个子问题的解。</li> <li>自我调用：将一个问题拆分成多个子问题求解。</li></ul></blockquote> <p>递归模板代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 最小子问题解<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>缩小问题规模<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以5的阶乘为例，演示递归求解过程：</p> <ul><li>先自顶向下拆分子问题，直到不能拆分为止；</li> <li>然后自底向上逐层把底层的解向上汇报，直至得到父问题的解。</li></ul> <p><img src="assets%5C1666040392754.png" alt="1666040392754"></p> <p>代码实现1：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>代码实现2：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归结束后，实现一些其他逻辑</span>
    <span class="token comment">// 在这里还能够执行一次操作，实现分治思想里合并的逻辑</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="尾递归"><a href="#尾递归" class="header-anchor">#</a> 尾递归</h3> <p>尾递归是指一个函数中的 return语句是返回一个函数的调用结果，即最后一步调用的函数返回值作为当前函数的结果返回。</p> <p>利用尾递归求解n!，代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* f(5, 1);
*
* @param n 求n!
* @param res 递归函数上一层的解，初始值为1
*/</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 没有合并过程，只是实现递归调用，然后当前函数作为结果返回</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>尾递归流程图：</p> <p><img src="assets%5C1666041504595.png" alt="1666041504595"></p> <h2 id="分而治之"><a href="#分而治之" class="header-anchor">#</a> 分而治之</h2> <p>分而治之（Divide and Conquer）就是把一个复杂的问题拆分成若干个子问题，然后再逐个求解，最后将子问题的解合并得到原问题的解。</p> <p>减治思想：分治思想的一种特殊情况。相比分治思想，减治没有合并的过程。它只是将父问题转换成一个规模更小的子问题（子问题的解就是上一层父问题的解），即每一步只需要解决一个规模更小的子问题。</p> <p>分治思想三步曲：==拆分=&gt;解决=&gt;合并==</p> <ol><li>将父问题拆分成结构相同的多个子问题。（拆分）</li> <li>求解拆分出来的子问题。（解决）</li> <li>将子问题的解合并得父问题的解。（合并）</li></ol> <blockquote><p>问题1：能够利用分治思想解决的问题一般都存在哪些特征？</p> <ul><li>父问题拆分出的子问题的解可以合并成父问题的解。</li> <li>父问题拆分出的子问题之间不包含公共子问题。</li></ul> <p>问题2：递归与枚举的区别？</p> <ul><li>枚举是横向的把问题划分，然后依次求解子问题。</li> <li>递归是纵向的把问题分解，然后依次求解子问题。</li></ul> <p>问题3：递归与分治的区别？</p> <p>递归是一种编程技巧，也是一种解决问题的思维方式；分治是一种思想，很大程度上是基于递归的，用来解决更具体的问题。</p></blockquote> <h1 id="搜索算法"><a href="#搜索算法" class="header-anchor">#</a> 搜索算法</h1> <p>DFS</p> <p>BFS</p> <h2 id="回溯"><a href="#回溯" class="header-anchor">#</a> 回溯</h2> <h1 id="贪心"><a href="#贪心" class="header-anchor">#</a> 贪心</h1> <h1 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h1> <h3 id="线性枚举"><a href="#线性枚举" class="header-anchor">#</a> 线性枚举</h3> <h3 id="二分枚举"><a href="#二分枚举" class="header-anchor">#</a> 二分枚举</h3> <h3 id="三分枚举"><a href="#三分枚举" class="header-anchor">#</a> 三分枚举</h3> <h3 id="离散化"><a href="#离散化" class="header-anchor">#</a> 离散化</h3> <h3 id="前缀和-2"><a href="#前缀和-2" class="header-anchor">#</a> 前缀和</h3> <h3 id="双指针"><a href="#双指针" class="header-anchor">#</a> 双指针</h3> <h1 id="⭐排序"><a href="#⭐排序" class="header-anchor">#</a> ⭐排序</h1> <h2 id="排序稳定性"><a href="#排序稳定性" class="header-anchor">#</a> 排序稳定性</h2> <p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p> <h2 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h2> <h2 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h2> <p>选择排序一般也被称为直接选择排序。它的核心原理是<code>每经过一轮比较，找到最值的下标，将它与首元素交换</code>。</p> <p>它与冒泡排序的不同之处在于冒泡排序在比较过程中就会不断进行交换；而选择排序则是每一轮选出最值并记录其下标，一轮比较结束后都会进行交换，从而减少了交换次数。</p> <p><img src="assets%5C2019030515170010-xuanzhepaixu1.gif" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkIndexOutOfBounds</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;使用了选择排序, 元素类型:&quot;</span> <span class="token operator">+</span> seq<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;原序列:&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> minIndex<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> seq<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="二元选择排序"><a href="#二元选择排序" class="header-anchor">#</a> 二元选择排序</h2> <p>二元选择排序是对选择排序的一种优化算法。它的基本思想与选择排序基本一致，只不过二元选择排序每一轮遍历时会找出最大值和最小值，一轮遍历结束后，将最小值与首元素交换，最大值与末尾元素交换，这样一来每一轮遍历就能够排好2个元素，使得无序序列遍历的范围缩小了一倍。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkIndexOutOfBounds</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> minIndex<span class="token punctuation">,</span> maxIndex<span class="token punctuation">;</span>
    <span class="token comment">// 遍历范围缩小一半</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token generics"><span class="token punctuation">&lt;</span> seq<span class="token punctuation">.</span>length <span class="token punctuation">&gt;</span></span><span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
        maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                maxIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 已经有序了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex <span class="token operator">==</span> maxIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 与首元素交换</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 与末尾元素交换</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="插入排序"><a href="#插入排序" class="header-anchor">#</a> 插入排序</h2> <p>插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。它的基本思想是将一个记录插入到已经排好序的序列中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p> <p><code>核心原理</code>：在新元素插入过程中与前面的数字不断做比较，如果当前元素比前面的元素小或大（升序或降序），前面的元素就向后挪出位置，当新元素找到合适的插入位置后，将元素覆盖掉原始元素，从而完成插入操作。</p> <p>以序列seq={5，2，4，6，1，3}为例，插入排序的排序过程如下所示：</p> <p><img src="assets%5C1666781082395.png" alt="1666781082395"></p> <p>插入排序动态流程图演示如下，待排序序列seq={6，2，1，3，5，4}。</p> <p><img src="assets%5C2019030515170010-zhijiecharupaixu.gif" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 对[start, end]区间元素进行排序
 * 
 * @param seq 待排序序列
 * @param start 起始索引
 * @param end 结束索引
 * @param comparator 排序器
 * @param &lt;E&gt; 元素类型
 */</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 临时变量, 用来交换元素</span>
    <span class="token class-name">E</span> temp<span class="token punctuation">;</span>
    <span class="token comment">// 从第2个元素开始，往前插入元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果seq[i]比seq[i-1]小，说明当前元素比它前面的元素小，所以需要交换</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 记录当前元素下标和元素值</span>
            j <span class="token operator">=</span> i<span class="token punctuation">;</span>
            temp <span class="token operator">=</span> seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 查找seq[i]元素待插入索引</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> start <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> seq<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 循环结束后，j就记录了seq[i]元素的插入索引</span>
            seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="二分插入排序"><a href="#二分插入排序" class="header-anchor">#</a> 二分插入排序</h2> <p>二分法插入排序，简称二分排序，它是插入排序的改进版本。传统插入排序中，要为待插入元素选择一个合适的插入位置时，需要从右向左扫描元素，元素查找的时间复杂度为O(N)。<strong>考虑到这个待查找的序列是有序的，因此，在插入第i个元素时，可以对前面<code>[0，i-1]</code>区间的元素进行折半查找</strong>，先跟他们的中间元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。</p> <h3 id="核心原理剖析"><a href="#核心原理剖析" class="header-anchor">#</a> 核心原理剖析</h3> <p>以序列seq=[25, 26, 12, 16, 20, 30, 21]为例，二分插入排序的排序过程如下。</p> <p>首先初始化start=0，end=6，idx=start+1=1，并且==[start，idx-1]区间的元素始终保持有序==。因此，当要为idx位置的元素寻找合适的插入位置时，可以利用二分查找来优化这个操作。现在开始查找操作：</p> <ol><li><p><code>第1趟</code>：初始化left=0，idx=1，right=idx-1=0，mid=(left+right)/2=0。当mid位置的元素大于idx位置的元素时，说明元素插入到到左半部分（right=mid-1）；当mid位置的元素小于idx位置的元素时，说明元素要插入到右半部分（left=mid+1)。</p></li> <li><p>显然25&lt;26成立，修改lef的值为1。此时left&gt;right，说明插入位置已经找到，此时的left位置就是idx位置元素的插入位置。因为idx等于left，因此不需要再将left位置之后的所有元素向后移动一位了。</p> <p><img src="assets%5C1667472314711.png" alt="1667472206808"></p></li> <li><p><code>第2趟</code>：初始化left=0，idx=2，right=idx-1=1，mid=(left+right)/2=0。显然25&gt;12成立，修改right的值为-1，left&gt;right说明已经找到插入位置，停止查找；查询结束后，先把[left,idx-1]区间的所有元素向后移动一位，最后将元素12插入到left位置。</p> <p><img src="assets%5C1667472637874.png" alt="1667472637874"></p></li> <li><p><code>第3趟</code>：初始化left=0，idx=3，right=idx-1=2，mid=(left+right)/2=1。显然25&gt;16成立，修改right的值为0，lefe不大于right说明还未找到插入位置，继续查找。此时12和16进行比较(12&lt;16)，修改left的值为1，结束查询操作；然后将[left,idx-1]区间的所有元素向后移动一位，最后把元素16插入到left位置。</p> <p><img src="assets%5C1667472930694.png" alt="1667472930694"></p></li> <li><p><code>第4趟</code>：初始化left=0，idx=4，right=idx-1=3，mid=(left+right)/2=1。显然16&lt;20成立，修改left的值为2，lefe不大于right说明还未找到插入位置，继续查找。此时25和20进行比较，显然25&gt;20成立，修改right的值为1，结束查询操作；继续将[left,idx-1]区间的所有元素向后移动一位，最后把元素20插入到left位置。</p> <p><img src="assets%5C1667473497886.png" alt="1667473497886"></p></li> <li><p>接下来的操作基本就是这样的一个逻辑了，如下图所示：</p></li></ol> <p><img src="assets%5C1667474177895.png" alt="1667474177895"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkIndexOutOfBounds</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 临时变量, 用来交换元素</span>
    <span class="token class-name">E</span> temp<span class="token punctuation">;</span>
    <span class="token comment">// 从第2个元素开始，往前插入元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> mid<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 记录当前元素值</span>
        temp <span class="token operator">=</span> seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 利用二分查找来获取seq[i]元素待插入的位置</span>
        left <span class="token operator">=</span> start<span class="token punctuation">;</span>
        right <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 查找到相同元素时，将当前元素插入到前面的位置</span>
                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将前面所有大于seq[i]的元素向后移动1位</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> left<span class="token punctuation">,</span> seq<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 循环结束后，left就记录了seq[i]元素的插入索引</span>
        seq<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="希尔排序"><a href="#希尔排序" class="header-anchor">#</a> 希尔排序</h2> <p>希尔排序(Shell Sort)是插入排序的一种改进版本。</p> <p><code>核心原理</code>：</p> <ol><li>将序列按照一定间隔拆分成多个子序列，然后对每一组子序列分别进行插入排序。间隔分组不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组；</li> <li>缩小间隔距离，进行下一轮排序，直到间隔距离为1；</li> <li>当执行最后一次排序时，间隔值应为 1，此时会对整个序列执行插入排序。</li></ol> <h3 id="原理剖析"><a href="#原理剖析" class="header-anchor">#</a> 原理剖析</h3> <p>以序列seq={84，83，88，87，61，50，70，60，80，99}为例，希尔排序排序的排序过程如下：</p> <p><img src="assets%5C1666836878621.png" alt="1666801115392"></p> <p>以下是希尔排序的动图展示：</p> <p><img src="assets%5C1354258-20210719104842616-924150811.gif" alt="img"></p> <p>代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 对[start, end]区间的元素进行排序
 *
 * @param seq 待排序序列
 * @param start 起始索引
 * @param end 结束索引
 * @param comparator 排序器
 * @param &lt;E&gt; 元素类型
 */</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 临时变量</span>
    <span class="token class-name">E</span> temp<span class="token punctuation">;</span>
    <span class="token comment">// 记录当前组中前一个元素的索引值</span>
    <span class="token keyword">int</span> prevIdx<span class="token punctuation">;</span>
    <span class="token comment">// int size = seq.length;</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token comment">// gap: 增量序列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> size <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">&gt;&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从gap开始，按照顺序将每个元素依次向前插入自己所在的组</span>
        <span class="token comment">// gap=5, idx:[5,size)</span>
        <span class="token comment">// gap=2, idx:[2,size)</span>
        <span class="token comment">// gap=1, idx:[1,size)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> gap<span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 记录当前元素</span>
            temp <span class="token operator">=</span> seq<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// j-gap: 表示获取该组中前一个元素的索引</span>
            prevIdx <span class="token operator">=</span> idx <span class="token operator">-</span> gap<span class="token punctuation">;</span>
            <span class="token comment">// 查找seq[idx]元素待插入的位置</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>prevIdx <span class="token operator">&gt;=</span> start <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> seq<span class="token punctuation">[</span>prevIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 比seq[idx]元素小的移动到它后面</span>
                <span class="token comment">// prevIdx+gap: 表示当前元素的索引值</span>
                seq<span class="token punctuation">[</span>prevIdx <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> seq<span class="token punctuation">[</span>prevIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
                prevIdx <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 循环结束后，prevIdx+gap就是seq[i]元素要插入位置</span>
            seq<span class="token punctuation">[</span>prevIdx <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="增量序列"><a href="#增量序列" class="header-anchor">#</a> 增量序列</h3> <p>Hibbard 增量序列：D_k = 2^k - 1，也就是 1,3,7,15,...{1, 3, 7, 15, ...}1,3,7,15,...。数学界猜想它最坏的时间复杂度为 O(n^{3/2})，平均时间复杂度为 O(n^{5/4}) ;
Knuth 增量序列：D1=1;Dk+1=3∗Dk+1D_1 = 1; D_{k+1} = 3 * D_k + 1D1=1;Dk+1=3∗Dk+1，也就是 1,4,13,40,...，数学界猜想它的平均时间复杂度为O(n^{3/2})；
Sedgewick 增量序列：1,5,19,41,109,...{1, 5, 19, 41, 109, ...}1,5,19,41,109,...，这个序列的元素有的是通过 9 * 4^k - 9 * 2^k + 1 计算出来的，有的是通过 4^k - 3 * 2^k + 1计算出来的。数学界猜想它最坏的时间复杂度为 O(n^{4/3})，平均时间复杂度为 O(n^{7/6})</p> <h3 id="性能测试"><a href="#性能测试" class="header-anchor">#</a> 性能测试</h3> <h2 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h2> <p>个人对堆排序的理解其实它就是选择排序，只不过是树形结构的选择排序。它与直接选择排序的不同之处在于直接选择排序从一个序列的[1，n]区间范围内选择出最值需要比较 n-1次，从[1，n-2]区间范围内选择出最值需比较n-2次，可以发现在之后的n-2次比较中，一定有很多已经在n-1次比较中处理过了，然而树形选择排序的优点就是记录这些已经比较过的结果，从而减少比较次数。</p> <p>要了解堆排序就必须了解二叉堆数据结构的基础知识。<strong>二叉堆是一颗完全二叉树，并且堆中每个节点的值总是不大于其父节点的值</strong></p> <p>二叉堆可分为大顶堆和小顶堆两种：</p> <ul><li><strong>大顶堆</strong>：堆中每一个节点的值都<code>大于等于</code>其孩子节点的值。大顶堆的堆根节点总是堆中最大值。</li> <li><strong>小顶堆</strong>：堆中每一个节点的值都<code>小于等于</code>其孩子节点的值。小顶堆的堆根节点总是堆中最小值。</li></ul> <p><img src="assets%5C1666872329931.png" alt="image-20210403031959497"></p> <h3 id="原理剖析-2"><a href="#原理剖析-2" class="header-anchor">#</a> 原理剖析</h3> <p>知道了二叉堆的基本概念以后，其排序原理也就变得简单了。如果要对序列进行升序排序，可以构建大顶堆；如果要对序列进行降序排序，可以构建小顶堆。</p> <p><strong>原地堆排序（升序）原理：</strong></p> <p><code>步骤1</code>：根据待排序序列构造一个大顶堆，取出堆顶元素，然后将根节点与最后一个节点交换。</p> <p><code>步骤2</code>：接着根据已有的元素（不包含已交换的元素）再调整为一个最大堆，重复步骤一，直到排序完成。</p> <p><img src="assets%5C2019030515170010-duipaixu.gif" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkIndexOutOfBounds</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将无序序列构建最大堆(升序)</span>
    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环删除堆顶元素，移到集合尾部</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> start<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将最后1个节点和第1个节点值进行交换</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> i<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调整最大堆结构</span>
        <span class="token function">buildHeap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>非原地堆排序（升序）原理：</strong></p> <p><code>步骤1</code>：根据待排序序列构造一个小顶堆，取出并删除堆顶元素，并将该元素存储到结果集合中；</p> <p><code>步骤2</code>：接着调整小顶堆的结构，重复步骤1，直到排序完成。</p> <p>两种算法的原理大致思路是一样的，不同点在于非原地堆排序需要额外空间用来存储排序结果集。</p> <h3 id="时间-空间复杂度-2"><a href="#时间-空间复杂度-2" class="header-anchor">#</a> 时间&amp;空间复杂度</h3> <p><code>稳定性</code>：对于长度为N的序列，最坏情况下每个节点需比较log2(n)次，因此最坏情况下时间复杂度为NlogN。堆排序是不稳定排序，不适合记录较少的排序。</p> <table><thead><tr><th>算法</th> <th>时间复杂度</th> <th>空间复杂度</th></tr></thead> <tbody><tr><td>原地堆排序</td> <td>O(NlogN)</td> <td>O(1)</td></tr> <tr><td>非原地堆排序</td> <td>O(NlogN)</td> <td>O(N)</td></tr></tbody></table> <h2 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h2> <p>快速排序是冒泡排序的一种改良算法。</p> <h3 id="单轴快排"><a href="#单轴快排" class="header-anchor">#</a> 单轴快排</h3> <p>单抽快排是快速排序的一种实现方式，它的核心是利用了分治思想。在每一轮序列中选取一个基准值（pivot），小于pivot值的放其左侧，大于pivot值的放其右侧，从而把序列拆分成了两个部分，然后在拆分出来的子序列中继续选取一个基准值，重复操作，从而得到一个有序序列。</p> <p>以序列seq={12，10，8，22，5，13，28，21，11}为例，快速排序的排序过程如下所示：</p> <p><img src="https://img-blog.csdnimg.cn/20210111133327527.png" alt="img"></p> <p>根据上图快速排序过程图可以衍生出两个问题。</p> <ul><li><p><code>问题1</code>：如何合理的选取基准值（pivot）？</p> <p><strong>最常见的方法就是以首元素为基准值。</strong></p></li> <li><p><code>问题2</code>：如何根据基准值对待排序序列中的元素进行划分，并且能够高效的完成排序操作？</p></li></ul> <h4 id="元素划分策略"><a href="#元素划分策略" class="header-anchor">#</a> 元素划分策略</h4> <h5 id="双向扫描"><a href="#双向扫描" class="header-anchor">#</a> 双向扫描</h5> <p><img src="https://img-blog.csdn.net/20170504125640821" alt="img"></p> <p>需要注意的点是，当i等于j时，此时该元素是未与基准值比较过的，因此也需要进行比较。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">selectPivot</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// left找比pivot大的, right找比pivot小的</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 找到之后交换left与right位置的值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将基准值设置在中间位置</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="挖坑填埋法"><a href="#挖坑填埋法" class="header-anchor">#</a> 挖坑填埋法</h5> <p><img src="https://img-blog.csdn.net/20170504125809679" alt="赋值填充过程图"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">selectPivot</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// right找比pivot小的值，left找比pivot大的值</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 此时left与right是相等</span>
        arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
        <span class="token function">sort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="单向扫描"><a href="#单向扫描" class="header-anchor">#</a> 单向扫描</h5> <p><img src="https://img-blog.csdn.net/20170504130404807" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 固定选择基准值</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> mark <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>mark<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort3</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mark <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort3</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mark <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="基准值选取策略"><a href="#基准值选取策略" class="header-anchor">#</a> 基准值选取策略</h4> <h5 id="固定法"><a href="#固定法" class="header-anchor">#</a> 固定法</h5> <p><code>核心思想</code>：选取首元素或尾元素作为基准值。</p> <p>之前编写的快速排序代码，都是基于固定法选择基准值来实现的。</p> <p>利用固定法选择法测试数据量为50万时，各种排序算法性能：</p> <table><thead><tr><th>算法</th> <th>升序序列</th> <th>降序序列</th> <th>随机序列</th> <th>重复序列</th></tr></thead> <tbody><tr><td>双向扫描法</td> <td><strong>34869ms</strong></td> <td><strong>30748ms</strong></td> <td><strong>60ms</strong></td> <td><strong>33999ms</strong></td></tr> <tr><td>挖坑填埋法</td> <td><strong>29155ms</strong></td> <td><strong>43887ms</strong></td> <td><strong>71ms</strong></td> <td><strong>20699ms</strong></td></tr> <tr><td>单向扫描法</td> <td><strong>20350ms</strong></td> <td><strong>84118ms</strong></td> <td><strong>41ms</strong></td> <td><strong>19157ms</strong></td></tr> <tr><td>三分单向扫描</td> <td><strong>340ms</strong></td> <td><strong>177624ms</strong></td> <td><strong>52ms</strong></td> <td><strong>3ms</strong></td></tr> <tr><td>三分双向扫描</td> <td><strong>35409ms</strong></td> <td><strong>177879ms</strong></td> <td><strong>61ms</strong></td> <td><strong>3ms</strong></td></tr></tbody></table> <p><code>测试结果分析</code>：综上可得，若待排序序列是随机的，排序效率还不错；若待排序序列已经有序了，此时快排形成的递归树就会退化成一个链表，快排将变成冒泡排序，时间复杂度为O(N^2)；若待排序序列中元素都是重复值过多，(1)(2)(3)三种算法显然处理的效率不高，而(4)(5)二种算法则能够轻松解决这一问题。在排序过程中，序列变成有序或部分有序的情况是比较常见的，因此，使用固定选择法不是一种特别好的方案。</p> <h5 id="随机法"><a href="#随机法" class="header-anchor">#</a> 随机法</h5> <p>假如现在要对一个有序（升序或降序）序列进行排序，此时快排形成的递归树就会退化成一个链表，时间复杂度将从O(NlogN)提升到O(N^2)。显然，此时若再使用固定法选取基准值，快排效率低下。随机选取基准值的出现就是为了解决待排序序列中部分有序的情况。</p> <p><code>核心思想</code>：选取待排序序列中任意一个元素作为基准值。</p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用随机选取法，测试数据量为50万时，各种排序算法性能：</p> <table><thead><tr><th>算法</th> <th>升序序列</th> <th>降序序列</th> <th>随机序列</th> <th>重复序列</th></tr></thead> <tbody><tr><td>双向扫描法</td> <td><strong>261ms</strong></td> <td><strong>268ms</strong></td> <td><strong>78ms</strong></td> <td><strong>40194ms</strong></td></tr> <tr><td>挖坑填埋法</td> <td><strong>43ms</strong></td> <td><strong>51ms</strong></td> <td><strong>75ms</strong></td> <td><strong>52525ms</strong></td></tr> <tr><td>单向扫描法</td> <td><strong>45ms</strong></td> <td><strong>52ms</strong></td> <td><strong>71ms</strong></td> <td><strong>26326ms</strong></td></tr> <tr><td>三分单向扫描</td> <td><strong>56ms</strong></td> <td><strong>54ms</strong></td> <td><strong>77ms</strong></td> <td><strong>2ms</strong></td></tr> <tr><td>三分双向扫描</td> <td><strong>51ms</strong></td> <td><strong>55ms</strong></td> <td><strong>99ms</strong></td> <td><strong>2ms</strong></td></tr></tbody></table> <p><code>测试结果分析</code>：综上可得，随机选择的优势就体现出来了，相对于固定选取法，整体的运行效率还是不错的，也是平时比较常用的基准值选取算法。虽然随机法可以应对序列有序的情况，但是，当待排序序列中的所有元素值相等时，利用(1)(2)(3)任意一种算法，递归树仍然会退化成链表，使得它的时间复杂度再次变成O(N ^ 2)。</p> <h5 id="三数取中"><a href="#三数取中" class="header-anchor">#</a> 三数取中</h5> <p>虽然随机选取基准值可以应对极端测试用例，减少递归树加深的概率，但它的最坏的时间复杂度还是O(N^2）。三数取中算法的出现就是为了缓解这一情况。</p> <p><code>核心思想</code>：首先选取首元素（startIndex）和尾元素（endIndex），根据它们的元素索引选取出中间元素（==midIndex=(startIndex+endIndex)/2==）作为基准值，并且这三个元素必须满足：<strong>首元素 &lt; 中间元素 &lt; 尾元素</strong>。</p> <p><img src="https://img-blog.csdnimg.cn/20181223214954975" alt="img"></p> <p><img src="https://img-blog.csdnimg.cn/20181223214954992" alt="img"></p> <p>算法实现：以end-1作为基准值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">middle</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调整三数的位置</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Comparable</span> left <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span>seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span>seq<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span>seq<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>middle<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> end<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将 mid 位置的基准值放在 end-1 位置</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">[</span>end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>算法实现：以start作为基准值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">middle</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调整三数的位置</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Comparable</span> left <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span>seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span>seq<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">)</span>seq<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>middle<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> end<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将 mid 位置的基准值放在 start 位置</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用三数取中法，测试数据量为50万时，各种排序算法性能：</p> <table><thead><tr><th>算法</th> <th>升序序列</th> <th>降序序列</th> <th>随机序列</th> <th>重复序列</th></tr></thead> <tbody><tr><td>双向扫描法</td> <td><strong>22ms</strong></td> <td><strong>60ms</strong></td> <td><strong>68ms</strong></td> <td><strong>19538ms</strong></td></tr> <tr><td>挖坑填埋法</td> <td><strong>24ms</strong></td> <td><strong>26ms</strong></td> <td><strong>56ms</strong></td> <td><strong>7456ms</strong></td></tr> <tr><td>单向扫描法</td> <td><strong>18ms</strong></td> <td><strong>20ms</strong></td> <td><strong>46ms</strong></td> <td><strong>10926ms</strong></td></tr> <tr><td>三分单向扫描</td> <td><strong>40ms</strong></td> <td><strong>30ms</strong></td> <td><strong>57ms</strong></td> <td><strong>2ms</strong></td></tr> <tr><td>三分双向扫描</td> <td><strong>33ms</strong></td> <td><strong>25ms</strong></td> <td><strong>49ms</strong></td> <td><strong>2ms</strong></td></tr></tbody></table> <p><code>测试结果分析</code>：综上可得，使用三数取中法选择基准值，快排的运行效率还是有很明显的提升，虽然缓解了递归树退化成链表的情况，但仍然没有在根本上解决这一问题。</p> <h4 id="随机化快排"><a href="#随机化快排" class="header-anchor">#</a> 随机化快排</h4> <p>随机选取法+单向扫描=随机化快排</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 随机化</span>
            <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">,</span> mark <span class="token operator">=</span> start<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>mark<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sort3</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mark <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sort3</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mark <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="双路快排"><a href="#双路快排" class="header-anchor">#</a> 双路快排</h4> <p>双路快排是随机化快排的改进版本。它解决了序列中存在大量与基准值（pivot）相同的元素时，划分出来的子序列长度极度不平衡的问题。极端情况下导致某一端递归树退化成链表，排序的时间复杂度退化成了O(N^2)。</p> <p><code>核心思想</code>：选取一个基准值（pivot），将小于等于pivot的元素放在左边，大于等于pivot的元素右边，通过将与pivot相同的元素平均分配到左右、子序列中，这样一来就不会造成一边数据量极大，另一边没有数据情况。从而保证了递归树的平衡性。</p> <p><img src="https://www.runoob.com/wp-content/uploads/2020/09/2WayQuickSort-01.png" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">selectPivot</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;=</span> start <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">++</span><span class="token punctuation">,</span> right<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort7</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort7</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="三路快排"><a href="#三路快排" class="header-anchor">#</a> 三路快排</h4> <p>三路快排是双路快排的改进版本。前面提到的3种元素划分策略和随机快排都是比较常用的，美知不足是的它们有一个共同的缺陷。如果待排序序列中有很多相同元素时，此时快排形成的递归树就会退化成一个链表，使得它的时间复杂度从N(NlogN)变为O(N ^ 2)。</p> <p>以待排序序列seq=[5，5，5，5，9，1，5]为例说明一下三分待排序序列的思想。</p> <p>首先用传统的二分思想划分序列，以首元素作为基准值（pivot），序列seq将会被划分成seq1=[1]和seq2=[5，5，5，5，5，9]两个子序列。显然，当序列seq中存在大量元素等于基准值时，序列二分策略就没有起到很好的作用，导致元素划分总是偏向某一端，造成某一端的递归树加深，形成一个链表。</p> <p>虽然二路快排在处理重复元素时，运行效率有明显提高，但是它终究是治标不治本，只是将这些重复元素均匀的分配到左、右子序列中，从而造成大量的交换和扫描次数。那有没有更好的解决方案呢？答案是有的。首先让我们先来看看什么是三分思想。</p> <p><code>三分思想</code>：假设以首元素为基准值（pivot），我们将等于pivot的元素单独划分出一个区间来存储，那么序列seq就被划分为了三份，分别是<strong>小于pivot的元素，等于pivot的元素，大于pivot的元素</strong>。如下图所示。我们只需要对左、右两部分排序就能保证序列的整体有序性。显然，这种元素划分策略可以大大的减少递归树的深度，</p> <p><img src="assets%5C1667308258918.png" alt="1667308258918"></p> <h5 id="单向扫描-2"><a href="#单向扫描-2" class="header-anchor">#</a> 单向扫描</h5> <p>下面是三分单向扫描算法的排序流程图。</p> <p><img src="assets%5Ckuaishupaixu-sanfendanxiansaomiaofa.png" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 固定选择基准值</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">,</span> index <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到小于pivot的元素</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">++</span><span class="token punctuation">,</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到大于pivot的元素</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right<span class="token operator">--</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到等于pivot的元素</span>
                index<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 等于pivot部分的元素不需要进行递归，因此，只需要递归小于pivot和大于pivot的部分</span>
        <span class="token function">sort4</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归小于pivot部分元素</span>
        <span class="token function">sort4</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归大于pivot部分元素</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="双向扫描-2"><a href="#双向扫描-2" class="header-anchor">#</a> 双向扫描</h5> <p>三分单向扫描方式已经完美的解决了待排序序列中存在重复元素时，递归树退化成一个链表的问题。美中不足的是，在三分单向扫描算法实现过程中，遍历到大于pivot的元素时会将末尾未扫描的元素（right位置）与当前元素（idx位置）进行交换。那有没有这样一种可能，如果当前right位置的元素大于pivot值，此时将元素进行交换，下一次与pivot比较时又得进行交换，这样无非就是增加了交换次数。</p> <p>因此，可以约定当遍历到大于pivot的元素时，从右往左先找到一个小于等于pivot的元素进行交换。具体排序过程如下图所示。</p> <p><img src="assets%5Ckuaishupaixu-sanfenshuangxiansaomiaofa.png" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 固定选择基准值</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">,</span> index <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token constant">LOOP</span><span class="token operator">:</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到小于pivot的元素</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">++</span><span class="token punctuation">,</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到大于pivot的元素</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 找出一个不大于pivot的元素进行交换</span>
                    right<span class="token operator">--</span><span class="token punctuation">;</span>
                    <span class="token comment">// 后面的待排元素全都大于pivot值，直接结束排序</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">break</span> <span class="token constant">LOOP</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">++</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
                index<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到等于pivot的元素</span>
                index<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 等于pivot部分的元素不需要进行递归，因此，只需要递归小于pivot和大于pivot的部分</span>
        <span class="token function">sort4</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归小于pivot部分元素</span>
        <span class="token function">sort4</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归大于pivot部分元素</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="双轴快排"><a href="#双轴快排" class="header-anchor">#</a> 双轴快排</h3> <p>首先我们会想到这样几个问题。</p> <blockquote><p>问题1：什么是双轴快排？</p> <p>问题2：使用双轴快排能解决什么问题？</p> <p>问题3：双轴快排的排序原理是什么？</p> <p>问题4：为什么双轴快排的效率要比单轴快排的效率好？</p></blockquote> <p>带着问题我们一起走进双轴快排的奇妙之旅。</p> <h4 id="什么是双轴快排"><a href="#什么是双轴快排" class="header-anchor">#</a> 什么是双轴快排</h4> <p>双轴快排顾名思义就是选取两个基准值，通常以待排序序列中的首元素（pivot1）和尾元素（pivot2）作为基准值，基准值必须满足<code>pivot1 &lt;= pivot2</code>条件。将序列划分成<code>e &lt; pivot1、pivot1 &lt;= e &lt;= pivot2，e &lt; pivot2</code>三个子序列，如下图所示，然后分别对这三个子序列进行排序，从而实现整体有序性。</p> <p><img src="assets%5C1667331287902.png" alt="1667331287902"></p> <p><img src="https://upload-images.jianshu.io/upload_images/5279526-d353a5235b266e47.png" alt="img"></p> <h4 id="核心原理剖析-2"><a href="#核心原理剖析-2" class="header-anchor">#</a> 核心原理剖析</h4> <p>双轴快排排序过程图如下所示：</p> <p><img src="assets%5Ckuaishupaixu-shuangzhoukuaishupaixu.png" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> pivot1 <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> pivot2 <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// pivot1始终小于pivot2</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pivot1 <span class="token operator">&gt;</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">,</span> index <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token constant">LOOP</span><span class="token operator">:</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到小于pivot1的元素</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>left<span class="token punctuation">,</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到pivot1 &lt;= arr[index] &lt;= pivot2的元素</span>
                index<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 遇到大于pivot2的元素</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">--</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">break</span> <span class="token constant">LOOP</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>left<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                index<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将pivot1和pivot2与left和right位置的元素交换</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> end<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 处理小于pivot的部分</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 处理小于等于pivot并且大于等于pivot的部分。left位置的值已经做为基准值处理过了</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 处理大于pivot的部分，right位置的值已经做为基准值处理过了</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="性能测试-2"><a href="#性能测试-2" class="header-anchor">#</a> 性能测试</h4> <p>现在我们有50万的测试数据，利用三种不同的基准值选取算法，双轴快排的运行效率如下所示：</p> <table><thead><tr><th>算法</th> <th>升序序列</th> <th>降序序列</th> <th>随机序列</th> <th>重复序列</th></tr></thead> <tbody><tr><td>固定法</td> <td><strong>27436ms</strong></td> <td><strong>24555ms</strong></td> <td><strong>169ms</strong></td> <td><strong>27339ms</strong></td></tr> <tr><td>随机法</td> <td><strong>303ms</strong></td> <td><strong>262ms</strong></td> <td><strong>159ms</strong></td> <td><strong>26520ms</strong></td></tr> <tr><td>三数取中</td> <td><strong>19ms</strong></td> <td><strong>28ms</strong></td> <td><strong>37ms</strong></td> <td><strong>26845ms</strong></td></tr></tbody></table> <p><code>测试结果分析</code>：综合可得，相对于随机化快排的方案，双轴快排+三数取中在运行效率上还是有明显的优势，但对于有大量重复元素的序列，这种极端情况时，递归树仍然会退化成链表，使得它的时间复杂度变成O(N ^ 2)。</p> <p>根据测试结果可以发现，双轴快排也没有解决序列中大量重复元素的问题。那它为什么性能要比单轴快排好呢？</p> <p>通过对比可以发现，如果按照元素元素扫描数来比较的话，单轴快排确实进行了更多的元素扫描动作，因此也就比较慢。在这种新的算法里面，双轴快排比 单轴快排节省了12%的元素扫描，从实验来看，双轴快排节省了10%的时间。</p> <p>相了解更多双轴快排性能相关的描述，可以去看看<a href="https://wuyaogexing.com/65/132698.html" target="_blank" rel="noopener noreferrer">这篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <blockquote><p><strong>个人总结：</strong></p> <p>通过对双轴快排的学习，我认识到了每一种算法都有自身存在的价值，它们有利有弊，没有好坏之分，只是需要不断的优化和创新，灵活运用，取长补短。就拿java中Arrays.sort来说，它的底层就是使用的双轴快排，但双不全是用的双轴快排。它提供了很多约束属性，规定什么时候该用插入排序，什么时候该用归并排序，什么时候该用三路快排，什么时候可以用计数排序，一个sort方法涉及到了很多排序算法，使我受益匪浅。</p></blockquote> <h3 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h3> <h4 id="优化1-提高小规模序列排序效率"><a href="#优化1-提高小规模序列排序效率" class="header-anchor">#</a> 优化1：提高小规模序列排序效率</h4> <p>当拆分的子序列元素较小时，利用插入排序相对于快速排序的效率会更可观，因此可以给定一个阈值，当待排序序列的长度小于这个阈值时，利用插入排序来提高小规模子序列的排序问题。</p> <h4 id="优化2-对相等元素不进行划分"><a href="#优化2-对相等元素不进行划分" class="header-anchor">#</a> 优化2：对相等元素不进行划分</h4> <p>元素划分过程中，约定将与基准值（pivot）相等的元素放在左右两端，进行下一次元素划分时跳过这部分的元素。</p> <p>以序列seq=[<strong>4</strong>，2，4，6，<strong>9</strong>，4，4，4，8，<strong>2</strong>]为例。利用三数取中法选取基准值（pivot），此时序列seq=[<strong>4</strong>，2，4，6，<strong>2</strong>，4，4，4，8，<strong>9</strong>]，pivot=4。</p> <blockquote><p>约定：将序列seq中与pivot值相同的元素分配到左右两端</p></blockquote> <h2 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h2> <p>归并排序与快速排序都是基于分治思想的排序算法。它的核心思想分为三个步骤：拆分 -&gt; 求解 -&gt; 合并。</p> <p><code>核心原理：</code></p> <ol><li>拆分：首先将待排序序列折半拆分，直到拆分到不能再拆分为止；</li> <li>求解：将拆分后的左侧子序列和右侧子序列进行排序；</li> <li>合并：将已经有序的左、右侧子序列进行合并，直到整个序列有序。</li></ol> <p>以下是归并排序分解图，拆分过程利用了二分思想。</p> <p><img src="assets%5C1666692135955.png" alt="1666662662302"></p> <p>下图具体展示归并排序分解-&gt;合并的每一个细节。可以发现归并排序的整个过程，其实就是不停的在拆分问题和组合子问题，最终得到原问题的解。</p> <p><img src="assets%5C2019030515170010.gif" alt="img"></p> <h3 id="合并有序序列"><a href="#合并有序序列" class="header-anchor">#</a> 合并有序序列</h3> <p>因为合并的左侧序列与右侧序列都是有序序列，所以两个有序序列中的最小元素肯定只能出现在序列的头部。</p> <p>当我们合并序列时，只需要比较两个序列的开头元素，选出最小的元素存储到一个临时区域，接着选出两个元素中第二小的元素，依次向下进行，直到将所有的元素按照指定顺序选出来，这样就把两个有序序列合并成一个更长的有序序列。</p> <p>假设有原始序列seq={4，5，7，8，1，2，3，5}，合并这两个有序序列的基本流程如下所示：</p> <p><img src="assets%5C1666666623385.png" alt="1666666623385"></p> <p>普通归并排序代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>seq<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 拆分</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 合并</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> leftIdx <span class="token operator">=</span> start<span class="token punctuation">,</span> rightIdx <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftIdx <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 左侧序列遍历完了</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>rightIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rightIdx <span class="token operator">&gt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 右侧序列遍历完了</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>leftIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> tmp<span class="token punctuation">[</span>rightIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 将较小的元素值保存到seq序列中</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>leftIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>rightIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="性能优化-2"><a href="#性能优化-2" class="header-anchor">#</a> 性能优化</h3> <p>优化前的归并排序存在哪些问题？</p> <ul><li><p><code>问题1</code>：每次拆分子序列时，都会开辟临时空间去存储子序列中的元素，造成每次拆分子序列都会重复创建一个临时空间去存储拆分出来的子序列。</p></li> <li><p><code>问题2</code>：当拆分的子数组元素较少时，利用归并排序相对于选择排序或插入排序的效率不是很可观。</p></li> <li><p><code>问题3</code>：有序序列合并之前，此时序列已经有序了，那么归并过程就显得毫无意义。</p></li></ul> <h4 id="优化1-减少临时空间的开辟"><a href="#优化1-减少临时空间的开辟" class="header-anchor">#</a> 优化1：减少临时空间的开辟</h4> <p>为了减少在递归过程中不断开辟临时空间的问题，可以在归并排序前预先开辟出一个临时空间，在递归过程中统一使用这一块临时空间即可。</p> <p><img src="assets%5C1666694316658.png" alt="1666694316658"></p> <h4 id="优化2-提高小规模序列排序效率"><a href="#优化2-提高小规模序列排序效率" class="header-anchor">#</a> 优化2：提高小规模序列排序效率</h4> <p>当拆分的子序列元素较小时，利用插入排序相对于归并排序的效率会更可观，因此可以给定一个阈值，当待排序序列的长度小于这个阈值时，利用插入排序来提高小规模子序列的排序问题</p> <p><img src="assets%5C1666694362787.png" alt="1666694362787"></p> <h4 id="优化3-提高合并序列效率"><a href="#优化3-提高合并序列效率" class="header-anchor">#</a> 优化3：提高合并序列效率</h4> <p>有序序列合并之前，可以通过左侧序列的最大值与右侧序列的最小值进行对比，确定是否进行复制比较，如果满足seq[mid] &lt;= seq[mid+1]条件，说明[0，mid+1]区间是一段有序序列，无需进行归并操作。因此序列本身有序的情况下时间复杂度可以降低到O(n)。</p> <p><img src="assets%5C1666694394608.png" alt="1666694394608"></p> <p>优化后的完整代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 预先开辟一块临时区域</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>seq<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 2. 当拆分的数组长度小于16的时，利用插入排序提高运行效率</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">&lt;=</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 序列拆分</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 2. 检测序列是否有序</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 序列合并</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> leftIdx <span class="token operator">=</span> start<span class="token punctuation">,</span> rightIdx <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftIdx <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 左侧序列遍历完了</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>rightIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rightIdx <span class="token operator">&gt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 右侧序列遍历完了</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>leftIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> tmp<span class="token punctuation">[</span>rightIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 将较小的元素值保存到seq序列中</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>leftIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>rightIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="时间复杂度对比"><a href="#时间复杂度对比" class="header-anchor">#</a> 时间复杂度对比</h3> <p>Java中的Arrays.sort方法有时采用的就是归并排序的优化版本TimSort，其余的采用双轴快速排序（DualPivotQuicksort）。</p> <p>Arrays类排序方法，以下sort方法均采用TimSort排序。</p> <p><img src="assets%5C1666696308120.png" alt="1666696308120"></p> <p>除此之外的基础数据类型的排序方法均采用双轴快速排序（DualPivotQuicksort）。</p> <p><code>long类型</code>：</p> <p><img src="assets%5C1666696662918.png" alt="1666696662918"></p> <p><code>double类型</code>：</p> <p><img src="assets%5C1666696618280.png" alt="1666696618280"></p> <p>List接口中的排序方法，间接的会调用Arrays.sort方法。</p> <p><img src="assets%5C1666696444285.png" alt="1666696444285"></p> <p>时间复杂度分析：</p> <table><thead><tr><th></th> <th>最好时间复杂度</th> <th>最坏时间复杂度</th> <th>平均时间复杂度</th> <th>空间复杂度</th> <th>稳定性</th></tr></thead> <tbody><tr><td>朴素归并排序</td> <td>O(NlogN)</td> <td>O(NlogN)</td> <td>O(NlogN)</td> <td>T(N)</td> <td>稳定</td></tr> <tr><td>优化后的归并排序</td> <td>O(N)</td> <td>O(NlogN)</td> <td>O(NlogN)</td> <td>T(N)</td> <td>稳定</td></tr> <tr><td>TimSort</td> <td>O(N)</td> <td>O(NlogN)</td> <td>O(NlogN)</td> <td>T(N)</td> <td>稳定</td></tr></tbody></table> <h3 id="原地归并排序"><a href="#原地归并排序" class="header-anchor">#</a> 原地归并排序</h3> <p>即使优化过的归并排序减少了临时空间的开辟，可仍然还需要预先申请一块额外空间，有什么办法能够节省出这块内存空间呢？原地归并排序（In-Place Merge Sort）的出现就是为了解决这一问题。</p> <h2 id="计数排序"><a href="#计数排序" class="header-anchor">#</a> 计数排序</h2> <h3 id="伪计数排序"><a href="#伪计数排序" class="header-anchor">#</a> 伪计数排序</h3> <p>举个例子，我们需要对一列数组排序，这个数组中每个元素都是 <code>[1,9]</code>区间内的整数。那么我们可以构建一个长度为 9 的数组用于计数，计数数组的下标分别对应区间内的 9 个整数。然后遍历待排序的数组，将区间内每个整数出现的次数统计到计数数组中对应下标的位置。最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数。</p> <p>伪计数排序流程图如下所示：</p> <p><img src="assets%5Cjishupaixu.gif" alt="img"></p> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h3 id="真计算排序"><a href="#真计算排序" class="header-anchor">#</a> 真计算排序</h3> <p>定义：与伪计数排序的区别在于它并不是把计数数组的下标直接作为结果输出，而是<strong>通过计数的结果，计算出每个元素在排序完成后的位置</strong>，然后将元素赋值到对应位置。</p> <p>假设有序列seq={7, 8, 9, 7, 6, 7, 6, 8, 6, 6}，根据计数排序定义分析其核心原理。</p> <p><code>过程分析</code>：</p> <p>（1）生成计数数组。统计得出数字6有4个，数字7有3个，数字8有2个，数字9有1个。计数数组counting=[0, 0, 0, 0, 0, 0, 4, 3, 2, 1]；</p> <p>（2）从左往右依次遍历seq序列。</p> <ul><li>遍历第1个元素seq[0]=7，根据计数数组可知有4个元素比它小，所以能确定seq[0]=7元素排序后的索引值为4。</li> <li>遍历第2个元素seq[1]=8，根据计数数组可知有7个元素比它小，所以能确定seq[1]=8元素排序后的索引值为7。</li> <li>遍历第3个元素seq[2]=9，根据计数数组可知有9个元素比它小，所以能确定seq[2]=8元素排序后的索引值为9。</li> <li>遍历第4个元素seq[3]=7，根据计数数组可知有4个元素比它小，按理说seq[3]=7的索引值也应该是4，但是这时的索引4位置已经存在一个值相同的元素，因此最终确定seq[3]=7元素排序后的索引值应该为5。</li> <li>依次类推，最终的排序序列seq={6, 6, 6, 6, 7, 7, 7, 8, 8, 9}。</li></ul> <p>算法实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><p>倒序遍历的计数排序：</p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h2 id="基数排序"><a href="#基数排序" class="header-anchor">#</a> 基数排序</h2> <p>基数排序可以分为以下三个步骤：</p> <ul><li>找出数组中最大的数字的位数（maxDigitLength）；</li> <li>获取数组中每个数字的基数；</li> <li>遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序。</li></ul> <p>原理图：</p> <p><img src="assets%5Cjspx.gif" alt="img"></p> <h3 id="计算基数"><a href="#计算基数" class="header-anchor">#</a> 计算基数</h3> <p><strong>基数</strong>：数字537分别由5，3，7组成，每一个位上的数称为基数。</p> <p><code>方式一</code>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">radix</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算value的位数</span>
    <span class="token keyword">int</span> bit <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 被除数</span>
    <span class="token keyword">int</span> dev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取基数值, 从低位开始获取</span>
        <span class="token keyword">int</span> radixVal <span class="token operator">=</span> value <span class="token operator">/</span> dev <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 7 =&gt; 3 =&gt; 5</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;radixVal:&quot;</span> <span class="token operator">+</span> radixVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dev <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>方式二</code>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">radix</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算value的位数</span>
    <span class="token keyword">int</span> bit <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 被除数 &amp; 被余数</span>
    <span class="token keyword">int</span> dev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> radixVal <span class="token operator">=</span> value <span class="token operator">%</span> mod <span class="token operator">/</span> dev<span class="token punctuation">;</span> <span class="token comment">// 7 =&gt; 3 =&gt; 5</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;radixVal:&quot;</span> <span class="token operator">+</span> radixVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dev <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>两者的区别是先做除法运算还是先做模运算，方式一可以节省一个变量。</p> <h2 id="桶排序"><a href="#桶排序" class="header-anchor">#</a> 桶排序</h2> <h3 id="什么是桶排序"><a href="#什么是桶排序" class="header-anchor">#</a> 什么是桶排序</h3> <p>桶排序(Bucket sort)是一种基于计数的排序算法，工作的原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。当要被排序的数据内的数值是均匀分配的时候，桶排序时间复杂度为Θ(n)。桶排序不同于快速排序，并不是比较排序，不受到时间复杂度 O(nlogn) 下限的影响。</p> <p>桶排序按下面4步进行：</p> <ul><li>设置固定数量的空桶。</li> <li>把数据放到对应的桶中。</li> <li>对每个不为空的桶中数据进行排序。</li> <li>\拼接从不为空的桶中数据，得到结果。</li></ul> <p>桶排序，主要适用于小范围整数数据，且独立均匀分布，可以计算的数据量很大，而且符合线性期望时间。</p> <blockquote><p>区间跨度 =（最大值 − 最小值）/（桶的数量 − 1）</p></blockquote> <p>[7, 36, 65, 56, 33, 60, 110, 42, 42, 94, 59, 22, 83, 84, 63, 77, 67, 101]</p> <p><img src="https://img2020.cnblogs.com/blog/1331592/202008/1331592-20200826091820352-1815228396.png" alt="img"></p> <div class="language-java extra-class"><pre class="language-java"><code>
</code></pre></div><h2 id="arrays-sort源码"><a href="#arrays-sort源码" class="header-anchor">#</a> Arrays.sort源码</h2> <p><img src="https://upload-images.jianshu.io/upload_images/5279526-afa3374292d0110f.png" alt="img"></p> <h2 id="外部排序"><a href="#外部排序" class="header-anchor">#</a> 外部排序</h2> <p>参考文档：</p> <ol><li>https://blog.csdn.net/qq_44629109/article/details/119779751</li> <li>https://blog.csdn.net/xushiyu1996818/article/details/84936832</li></ol> <h3 id="多路归并排序"><a href="#多路归并排序" class="header-anchor">#</a> 多路归并排序</h3> <h4 id="胜者树"><a href="#胜者树" class="header-anchor">#</a> 胜者树</h4> <h4 id="败者树"><a href="#败者树" class="header-anchor">#</a> 败者树</h4> <h2 id="应用与实践-4"><a href="#应用与实践-4" class="header-anchor">#</a> 应用与实践</h2> <h3 id="java中的排序算法"><a href="#java中的排序算法" class="header-anchor">#</a> java中的排序算法</h3> <h1 id="分块"><a href="#分块" class="header-anchor">#</a> 分块</h1> <p>块状数组</p> <p>块状链表</p> <p>块状树</p> <h1 id="查找算法"><a href="#查找算法" class="header-anchor">#</a> 查找算法</h1> <p>二分查找</p> <p>三分查找</p> <p>分块查找</p> <h1 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h1> <h1 id="前缀和-差分"><a href="#前缀和-差分" class="header-anchor">#</a> 前缀和 &amp; 差分</h1> <h1 id="数学相关"><a href="#数学相关" class="header-anchor">#</a> 数学相关</h1> <h2 id="快速幂"><a href="#快速幂" class="header-anchor">#</a> 快速幂</h2> <h1 id="其它算法"><a href="#其它算法" class="header-anchor">#</a> 其它算法</h1> <h2 id="快速选择算法"><a href="#快速选择算法" class="header-anchor">#</a> 快速选择算法</h2> <p>https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/215-shu-zu-zhong-de-di-kge-zui-da-yuan-s-rfvg</p> <h3 id="数组中第k个大元素"><a href="#数组中第k个大元素" class="header-anchor">#</a> 数组中第K个大元素</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">fastSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">middleOfStart</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seq<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&gt;</span> seq<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&gt;</span> seq<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>seq<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> seq<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">fastSelect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 利用快排思想做一个降序操作</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">middleOfStart</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">,</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> index <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token operator">++</span>left<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        index<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将基准值设置成中间元素</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前元素就是第k个最大元素</span>
        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// left值偏大说明第k大元素在left指针的左边。只需要遍历[start, left-1]区间的元素即可</span>
        <span class="token keyword">return</span> <span class="token function">fastSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// left值偏小说明第k大元素在left指针的右边。只需要遍历[left+1, end]区间的元素即可</span>
        <span class="token keyword">return</span> <span class="token function">fastSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h1> <ol><li><a href="https://blog.csdn.net/sokoooo/article/details/122348006" target="_blank" rel="noopener noreferrer">邻接矩阵<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://m.runoob.com/data-structures" target="_blank" rel="noopener noreferrer">菜鸟教程之数据结构篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/ACdreamers/article/details/16902023" target="_blank" rel="noopener noreferrer">深度理解链式前向星<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/weixin_50564032/article/details/123454395" target="_blank" rel="noopener noreferrer">【数据结构】图-图的存储_链式前向星<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/weixin_48524215/article/details/119321091" target="_blank" rel="noopener noreferrer">KMP模式匹配算法改进<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.45fan.com/article.php?aid=1CZC3fA6Uy29i1hB#_label5" target="_blank" rel="noopener noreferrer">Java中BM(Boyer-Moore)算法的图解与实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/codeOfLife/p/5547281.html" target="_blank" rel="noopener noreferrer">字符串匹配算法-BM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/bestsort/article/details/82947639" target="_blank" rel="noopener noreferrer">AC自动机算法详解(图解)及C++模板<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/xuanzui/article/details/126426754" target="_blank" rel="noopener noreferrer">AC自动机（Java版）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/weixin_43501684/article/details/124213569" target="_blank" rel="noopener noreferrer">Z函数（扩展KMP）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://events.jianshu.io/p/b3ce9b216c5b" target="_blank" rel="noopener noreferrer">后缀树详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.likecs.com/show-203784379.html?sc=1019" target="_blank" rel="noopener noreferrer">后缀数组详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.itdaan.com/blog/2018/04/23/d8c2bf1a693b49a659a1e05cbec0df0f.html" target="_blank" rel="noopener noreferrer">后缀数组详解及java实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/Frather/p/14590351.html" target="_blank" rel="noopener noreferrer">分块思想&amp;分块数组<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/weixin_45970271/article/details/124460317" target="_blank" rel="noopener noreferrer">归并排序详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/Holmofy/article/details/71168530" target="_blank" rel="noopener noreferrer">快速排序详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/Cherishlife_/article/details/85226755" target="_blank" rel="noopener noreferrer">快速排序之三数取中法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/yao_wen_yu/article/details/120967824" target="_blank" rel="noopener noreferrer">线索二叉树详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/yjw123456/article/details/105159817" target="_blank" rel="noopener noreferrer">十分钟弄懂什么是跳表，不懂可以来打我<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/fireway/p/10068892.html#item1_2" target="_blank" rel="noopener noreferrer">Java数据结构和算法-堆<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#💡一维数组" class="sidebar-link reco-side-💡一维数组" data-v-b57cc07c>💡一维数组</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#动态数组" class="sidebar-link reco-side-动态数组" data-v-b57cc07c>动态数组</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二维数组" class="sidebar-link reco-side-二维数组" data-v-b57cc07c>二维数组</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#稀疏数组" class="sidebar-link reco-side-稀疏数组" data-v-b57cc07c>稀疏数组</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#静态链表" class="sidebar-link reco-side-静态链表" data-v-b57cc07c>静态链表</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#动态链表" class="sidebar-link reco-side-动态链表" data-v-b57cc07c>动态链表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单链表" class="sidebar-link reco-side-单链表" data-v-b57cc07c>单链表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#符号链表" class="sidebar-link reco-side-符号链表" data-v-b57cc07c>符号链表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#跳表" class="sidebar-link reco-side-跳表" data-v-b57cc07c>跳表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#双向链表" class="sidebar-link reco-side-双向链表" data-v-b57cc07c>双向链表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#哈希链表" class="sidebar-link reco-side-哈希链表" data-v-b57cc07c>哈希链表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#循环链表" class="sidebar-link reco-side-循环链表" data-v-b57cc07c>循环链表</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#字符串哈希" class="sidebar-link reco-side-字符串哈希" data-v-b57cc07c>字符串哈希</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#字符串匹配" class="sidebar-link reco-side-字符串匹配" data-v-b57cc07c>字符串匹配</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单模式匹配" class="sidebar-link reco-side-单模式匹配" data-v-b57cc07c>单模式匹配</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#多模式匹配" class="sidebar-link reco-side-多模式匹配" data-v-b57cc07c>多模式匹配</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#数组模拟栈" class="sidebar-link reco-side-数组模拟栈" data-v-b57cc07c>数组模拟栈</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#链表模拟栈" class="sidebar-link reco-side-链表模拟栈" data-v-b57cc07c>链表模拟栈</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单调栈" class="sidebar-link reco-side-单调栈" data-v-b57cc07c>单调栈</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#最值栈" class="sidebar-link reco-side-最值栈" data-v-b57cc07c>最值栈</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#逆波兰表达式" class="sidebar-link reco-side-逆波兰表达式" data-v-b57cc07c>逆波兰表达式</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#应用与实践-2" class="sidebar-link reco-side-应用与实践-2" data-v-b57cc07c>应用与实践</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#数组模拟队列" class="sidebar-link reco-side-数组模拟队列" data-v-b57cc07c>数组模拟队列</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#链表模拟队列" class="sidebar-link reco-side-链表模拟队列" data-v-b57cc07c>链表模拟队列</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#循环队列" class="sidebar-link reco-side-循环队列" data-v-b57cc07c>循环队列</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#双端队列" class="sidebar-link reco-side-双端队列" data-v-b57cc07c>双端队列</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单调队列" class="sidebar-link reco-side-单调队列" data-v-b57cc07c>单调队列</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#最值队列" class="sidebar-link reco-side-最值队列" data-v-b57cc07c>最值队列</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#应用与实践-3" class="sidebar-link reco-side-应用与实践-3" data-v-b57cc07c>应用与实践</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#最值问题" class="sidebar-link reco-side-最值问题" data-v-b57cc07c>最值问题</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#dp优化" class="sidebar-link reco-side-dp优化" data-v-b57cc07c>DP优化</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#前缀和" class="sidebar-link reco-side-前缀和" data-v-b57cc07c>前缀和</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#存储结构-5" class="sidebar-link reco-side-存储结构-5" data-v-b57cc07c>存储结构</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#双亲表示法" class="sidebar-link reco-side-双亲表示法" data-v-b57cc07c>双亲表示法</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#孩子表示法" class="sidebar-link reco-side-孩子表示法" data-v-b57cc07c>孩子表示法</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#双亲孩子表示法" class="sidebar-link reco-side-双亲孩子表示法" data-v-b57cc07c>双亲孩子表示法</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#孩子兄弟表示法" class="sidebar-link reco-side-孩子兄弟表示法" data-v-b57cc07c>孩子兄弟表示法</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二叉树" class="sidebar-link reco-side-二叉树" data-v-b57cc07c>二叉树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#特殊二叉树" class="sidebar-link reco-side-特殊二叉树" data-v-b57cc07c>特殊二叉树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#存储结构-6" class="sidebar-link reco-side-存储结构-6" data-v-b57cc07c>存储结构</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#遍历方式" class="sidebar-link reco-side-遍历方式" data-v-b57cc07c>遍历方式</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#线索二叉树" class="sidebar-link reco-side-线索二叉树" data-v-b57cc07c>线索二叉树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#哈夫曼树" class="sidebar-link reco-side-哈夫曼树" data-v-b57cc07c>哈夫曼树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二叉搜索树-2" class="sidebar-link reco-side-二叉搜索树-2" data-v-b57cc07c>二叉搜索树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#平衡二叉树-2" class="sidebar-link reco-side-平衡二叉树-2" data-v-b57cc07c>平衡二叉树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#红黑树" class="sidebar-link reco-side-红黑树" data-v-b57cc07c>红黑树</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#树与森林" class="sidebar-link reco-side-树与森林" data-v-b57cc07c>树与森林</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#树-2" class="sidebar-link reco-side-树-2" data-v-b57cc07c>树</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#森林" class="sidebar-link reco-side-森林" data-v-b57cc07c>森林</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#并查集" class="sidebar-link reco-side-并查集" data-v-b57cc07c>并查集</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#n叉树" class="sidebar-link reco-side-n叉树" data-v-b57cc07c>N叉树</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二叉堆" class="sidebar-link reco-side-二叉堆" data-v-b57cc07c>二叉堆</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#构建建堆" class="sidebar-link reco-side-构建建堆" data-v-b57cc07c>构建建堆</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#插入操作-8" class="sidebar-link reco-side-插入操作-8" data-v-b57cc07c>插入操作</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#删除操作-8" class="sidebar-link reco-side-删除操作-8" data-v-b57cc07c>删除操作</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#手写二叉堆" class="sidebar-link reco-side-手写二叉堆" data-v-b57cc07c>手写二叉堆</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#时间-空间复杂度" class="sidebar-link reco-side-时间-空间复杂度" data-v-b57cc07c>时间&amp;空间复杂度</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#左偏堆" class="sidebar-link reco-side-左偏堆" data-v-b57cc07c>左偏堆</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#配对堆" class="sidebar-link reco-side-配对堆" data-v-b57cc07c>配对堆</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#无向图" class="sidebar-link reco-side-无向图" data-v-b57cc07c>无向图</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#有向图" class="sidebar-link reco-side-有向图" data-v-b57cc07c>有向图</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#带权图" class="sidebar-link reco-side-带权图" data-v-b57cc07c>带权图</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#带权无向图" class="sidebar-link reco-side-带权无向图" data-v-b57cc07c>带权无向图</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#带权有向图" class="sidebar-link reco-side-带权有向图" data-v-b57cc07c>带权有向图</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#完全图" class="sidebar-link reco-side-完全图" data-v-b57cc07c>完全图</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#无向完全图" class="sidebar-link reco-side-无向完全图" data-v-b57cc07c>无向完全图</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#有向完全图" class="sidebar-link reco-side-有向完全图" data-v-b57cc07c>有向完全图</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#连通图" class="sidebar-link reco-side-连通图" data-v-b57cc07c>连通图</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#存储方式" class="sidebar-link reco-side-存储方式" data-v-b57cc07c>存储方式</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#邻接矩阵" class="sidebar-link reco-side-邻接矩阵" data-v-b57cc07c>邻接矩阵</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#邻接表" class="sidebar-link reco-side-邻接表" data-v-b57cc07c>邻接表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#十字链表" class="sidebar-link reco-side-十字链表" data-v-b57cc07c>十字链表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#多重邻接表" class="sidebar-link reco-side-多重邻接表" data-v-b57cc07c>多重邻接表</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#边集数组" class="sidebar-link reco-side-边集数组" data-v-b57cc07c>边集数组</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#链式前向星" class="sidebar-link reco-side-链式前向星" data-v-b57cc07c>链式前向星</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#遍历方式-2" class="sidebar-link reco-side-遍历方式-2" data-v-b57cc07c>遍历方式</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#深度优先搜索" class="sidebar-link reco-side-深度优先搜索" data-v-b57cc07c>深度优先搜索</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#广度优先搜索" class="sidebar-link reco-side-广度优先搜索" data-v-b57cc07c>广度优先搜索</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#递归" class="sidebar-link reco-side-递归" data-v-b57cc07c>递归</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#尾递归" class="sidebar-link reco-side-尾递归" data-v-b57cc07c>尾递归</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#分而治之" class="sidebar-link reco-side-分而治之" data-v-b57cc07c>分而治之</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#回溯" class="sidebar-link reco-side-回溯" data-v-b57cc07c>回溯</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#线性枚举" class="sidebar-link reco-side-线性枚举" data-v-b57cc07c>线性枚举</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二分枚举" class="sidebar-link reco-side-二分枚举" data-v-b57cc07c>二分枚举</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#三分枚举" class="sidebar-link reco-side-三分枚举" data-v-b57cc07c>三分枚举</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#离散化" class="sidebar-link reco-side-离散化" data-v-b57cc07c>离散化</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#前缀和-2" class="sidebar-link reco-side-前缀和-2" data-v-b57cc07c>前缀和</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#双指针" class="sidebar-link reco-side-双指针" data-v-b57cc07c>双指针</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#排序稳定性" class="sidebar-link reco-side-排序稳定性" data-v-b57cc07c>排序稳定性</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#冒泡排序" class="sidebar-link reco-side-冒泡排序" data-v-b57cc07c>冒泡排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#选择排序" class="sidebar-link reco-side-选择排序" data-v-b57cc07c>选择排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二元选择排序" class="sidebar-link reco-side-二元选择排序" data-v-b57cc07c>二元选择排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#插入排序" class="sidebar-link reco-side-插入排序" data-v-b57cc07c>插入排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#二分插入排序" class="sidebar-link reco-side-二分插入排序" data-v-b57cc07c>二分插入排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#核心原理剖析" class="sidebar-link reco-side-核心原理剖析" data-v-b57cc07c>核心原理剖析</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#希尔排序" class="sidebar-link reco-side-希尔排序" data-v-b57cc07c>希尔排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原理剖析" class="sidebar-link reco-side-原理剖析" data-v-b57cc07c>原理剖析</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#增量序列" class="sidebar-link reco-side-增量序列" data-v-b57cc07c>增量序列</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#性能测试" class="sidebar-link reco-side-性能测试" data-v-b57cc07c>性能测试</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#堆排序" class="sidebar-link reco-side-堆排序" data-v-b57cc07c>堆排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原理剖析-2" class="sidebar-link reco-side-原理剖析-2" data-v-b57cc07c>原理剖析</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#时间-空间复杂度-2" class="sidebar-link reco-side-时间-空间复杂度-2" data-v-b57cc07c>时间&amp;空间复杂度</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#快速排序" class="sidebar-link reco-side-快速排序" data-v-b57cc07c>快速排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#单轴快排" class="sidebar-link reco-side-单轴快排" data-v-b57cc07c>单轴快排</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#双轴快排" class="sidebar-link reco-side-双轴快排" data-v-b57cc07c>双轴快排</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#性能优化" class="sidebar-link reco-side-性能优化" data-v-b57cc07c>性能优化</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#归并排序" class="sidebar-link reco-side-归并排序" data-v-b57cc07c>归并排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#合并有序序列" class="sidebar-link reco-side-合并有序序列" data-v-b57cc07c>合并有序序列</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#性能优化-2" class="sidebar-link reco-side-性能优化-2" data-v-b57cc07c>性能优化</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#时间复杂度对比" class="sidebar-link reco-side-时间复杂度对比" data-v-b57cc07c>时间复杂度对比</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#原地归并排序" class="sidebar-link reco-side-原地归并排序" data-v-b57cc07c>原地归并排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#计数排序" class="sidebar-link reco-side-计数排序" data-v-b57cc07c>计数排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#伪计数排序" class="sidebar-link reco-side-伪计数排序" data-v-b57cc07c>伪计数排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#真计算排序" class="sidebar-link reco-side-真计算排序" data-v-b57cc07c>真计算排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#基数排序" class="sidebar-link reco-side-基数排序" data-v-b57cc07c>基数排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#计算基数" class="sidebar-link reco-side-计算基数" data-v-b57cc07c>计算基数</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#桶排序" class="sidebar-link reco-side-桶排序" data-v-b57cc07c>桶排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#什么是桶排序" class="sidebar-link reco-side-什么是桶排序" data-v-b57cc07c>什么是桶排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#arrays-sort源码" class="sidebar-link reco-side-arrays-sort源码" data-v-b57cc07c>Arrays.sort源码</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#外部排序" class="sidebar-link reco-side-外部排序" data-v-b57cc07c>外部排序</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#多路归并排序" class="sidebar-link reco-side-多路归并排序" data-v-b57cc07c>多路归并排序</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#应用与实践-4" class="sidebar-link reco-side-应用与实践-4" data-v-b57cc07c>应用与实践</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#java中的排序算法" class="sidebar-link reco-side-java中的排序算法" data-v-b57cc07c>java中的排序算法</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#快速幂" class="sidebar-link reco-side-快速幂" data-v-b57cc07c>快速幂</a></li><li class="level-2" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#快速选择算法" class="sidebar-link reco-side-快速选择算法" data-v-b57cc07c>快速选择算法</a></li><li class="level-3" data-v-b57cc07c><a href="/ichigo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#数组中第k个大元素" class="sidebar-link reco-side-数组中第k个大元素" data-v-b57cc07c>数组中第K个大元素</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div></div></div></div>
    <script src="/ichigo/assets/js/app.8ce08534.js" defer></script><script src="/ichigo/assets/js/3.440a4598.js" defer></script><script src="/ichigo/assets/js/1.7543bd4f.js" defer></script><script src="/ichigo/assets/js/11.d88a996d.js" defer></script><script src="/ichigo/assets/js/9.00897824.js" defer></script>
  </body>
</html>
